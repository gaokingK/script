# link
  - local_doc
  - https://www.cnblogs.com/aspirant/p/9214485.html
  - [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
  - [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)
  - [浅谈算法和数据结构: 十 平衡查找树之B树，而这篇博文里有B树和B+树插入元素的过程GIF图，超赞，有助于对B树和B+树的理解！]()
  - [MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)
# 问题
- 索引如果是连贯的1,2,3....10, 那非叶子节点存储什么？
- BTree索引时，like中没有常量不会使用索引是啥意思？question_1
- 为什么 定义有外键的字段一定要建立索引？
- B树和B+树的区别就是B+树的内部结点只存放键，叶子节点同时存放键值。这里的键和值分别指的什么？
  - 键是索引的值，值是指向当前行的地址吗？还是当前行的数据？
  - 键是索引的值，值是一个指针（指向关键字具体信息的地址）来源于上面的链接[从B树、B+树、B*树谈到R 树]
  - 并不一定是数据行的地址，非聚簇索引是主键
- 回表到底是什么意思？是select内容是索引的内容吗？那为什么hash任何时候都要回表，而B+树在索引覆盖，聚簇索引情况下不需要回表呢？
  - 看##回表
  - [为什么非聚簇索引的叶子节点不包含整行数据的地址呢？](https://blog.csdn.net/moakun/article/details/81813994)
  - 有一种说法是 回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树. 即可能非聚簇索引存放的也是数据行的地址，但是数据行只能通过id取出来，而这个id是通过在扫描聚簇索引来获取的（感觉不太对，因为前者的数据行都没用哎，既然没有用还加它干嘛呢）
# 索引的一些语法
```
# 查看已有的索引
- http://c.biancheng.net/view/7364.html
show index from emp;
# 建立普通索引 
alter table tbl_name add index field_name;
ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); # 普通组合索引

# 查看可用索引
explain select * from tbl_a wher field_a xxx # possible_key可用索引， key用来检索的索引

# 唯一索引
ALTER TABLE table_name ADD UNIQUE(column);创建唯一索引
ALTER TABLE table_name ADD UNIQUE(column1,column2);创建唯一组合索引

# 创建全文索引
ALTER TABLE table_name ADD FULLTEXT(column， column2);
```
### 查看索引
- 组合索引并不会在一行中全部展示出来，key_name相同的就是一个索引，这个组合索引有几个组成就会有几列，seq_in_index就是建立组合索引时这几列的顺序从1开始
- ![](../../imgs/show_index_01.png)

# 索引的一些名词
- 键和索引等同
- 聚集索引和聚簇索引等同、辅助索引和非聚簇索引等同
- 组合索引、复合索引、联合索引 要统一
- 随机检索和顺序检索
  - 随机检索就是查a，查d，下一个不一定是查啥
  - 顺序检索就是查a，查b（也可能是查c吧）就是虽然不连续，但是是有序的
- 索引覆盖
- 索引是有序的？
- 节点又被称为页，页的大小是固定的，InnoDB中页的大小默认是16KB
- B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”
- 扫库：遍历表 B+树方便扫库
- 倒排表
  - link：https://blog.csdn.net/xiaoyu4009/article/details/46426667
  - 简单来说就是 根据关键字来找内容
  - 为什么称为倒呢？从原文中遍历去找关键字，这种找法称为正。相对于这种，从关键字找出相应的位置就叫做倒
- 而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
- 减少时间代价较大/性能下降较大 的磁盘IO操作的次数
## 什么是索引
- 索引是是帮助数据库高效获取数据的数据结构。是一种特殊的文件(会占物理空间的。InnoDB数据表上的索引是表空间的一个组成部分)，它包含一个表中某些列的值（建立索引的列）以及记录对应的地址。
- 索引是一种数据结构(后面会讲索引的数据结构）。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 为什么要使用索引
- 数据库的一个重要功能就是查询，一个查询需要遍历全表去扫描，而随着数据量越来越大，所花费的时间就会越来越长。而索引是有序排列的，所以可以加速查询
- select name，... from tbl_name where name="xxx"; 数据库就需要遍历全表，对每条数据来比对name是不是xxx，而当我们对name建立索引时，在查找时就能迅速定位到xxx在索引中的记录，进而能获取到表中对应的记录。

## 索引的使用场景
- 一个字段上能建立多种索引，如果有多个，查询的时候会选一个较优的来作为检索的依据。（？怎么知道是最优呢 mysql自己做的）
- 不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。？

- 查询
  - select * from tbl_a where field_a xxx; 当field_a上建立了索引时，使用该字段查询的效率会有明显的提升（数据量越大越明显）。
  - 索引覆盖
    - 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖
    - 因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- order_by 排序时
  - 将结果按照某个字段排序时，如果该字段没有建立索引，会使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。（从磁盘取数据是最影响性能的）
  - 如果建立了索引， 由于索引本身是有序的，可以直接按照索引的顺序和映射关系逐条取出数据就可以。
- join
  - 对join语句匹配关系（on）涉及的字段建立索引能够提高效率

## 索引的类型
- 主键索引
  - 一个表只能有一列是；值不允许为null；值不允许重复
- 唯一索引
  - 一个表能有多列是；值允许为null；值不允许重复
  - 分唯一索引与唯一组合索引（多列）
- 普通索引
  - 基本的索引类型，值允许为null；允许重复
- 全文索引 fulltext
  - link
    - https://blog.csdn.net/mrzhouxiaofei/article/details/79940958
    - https://blog.csdn.net/qq_18975791/article/details/102650479

  - 如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。
  - like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。
  - 对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。
  - 使用 `select * from tbl_name where MATCH(建立全文索引的列) AGAINST(关键词)`



