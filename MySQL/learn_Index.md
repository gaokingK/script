# link
  - local_doc
  - https://www.cnblogs.com/aspirant/p/9214485.html
  - [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
  - [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)
  - [浅谈算法和数据结构: 十 平衡查找树之B树，而这篇博文里有B树和B+树插入元素的过程GIF图，超赞，有助于对B树和B+树的理解！]()
  - [MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)
# 问题
- 索引如果是连贯的1,2,3....10, 那非叶子节点存储什么？
- BTree索引时，like中没有常量不会使用索引是啥意思？question_1
- 为什么 定义有外键的字段一定要建立索引？
- B树和B+树的区别就是B+树的内部结点只存放键，叶子节点同时存放键值。这里的键和值分别指的什么？
  - 键是索引的值，值是指向当前行的地址吗？还是当前行的数据？
  - 键是索引的值，值是一个指针（指向关键字具体信息的地址）来源于上面的链接[从B树、B+树、B*树谈到R 树]
  - 并不一定是数据行的地址，非聚簇索引是主键
- 回表到底是什么意思？是select内容是索引的内容吗？那为什么hash任何时候都要回表，而B+树在索引覆盖，聚簇索引情况下不需要回表呢？
  - [为什么非聚簇索引的叶子节点不包含整行数据的地址呢？](https://blog.csdn.net/moakun/article/details/81813994)
  - 有一种说法是 回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树. 即可能非聚簇索引存放的也是数据行的地址，但是数据行只能通过id取出来，而这个id是通过在扫描聚簇索引来获取的（感觉不太对，因为前者的数据行都没用哎，既然没有用还加它干嘛呢）
# 索引的一些语法
```
# 建立普通索引 
alter table tbl_name add index field_name;
ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); # 普通组合索引

# 查看可用索引
explain select * from tbl_a wher field_a xxx # possible_key可用索引， key用来检索的索引

# 唯一索引
ALTER TABLE table_name ADD UNIQUE(column);创建唯一索引
ALTER TABLE table_name ADD UNIQUE(column1,column2);创建唯一组合索引

# 创建全文索引
ALTER TABLE table_name ADD FULLTEXT(column， column2);
```
# 索引的一些名词
- 键和索引等同
- 聚集索引和聚簇索引等同、辅助索引和非聚簇索引等同
- 组合索引、复合索引、联合索引 要统一
- 随机检索和顺序检索
  - 随机检索就是查a，查d，下一个不一定是查啥
  - 顺序检索就是查a，查b（也可能是查c吧）就是虽然不连续，但是是有序的
- 索引覆盖
- 索引是有序的？
- 节点又被称为页，页的大小是固定的，InnoDB中页的大小默认是16KB
- B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”
- 扫库：遍历表 B+树方便扫库
- 倒排表
  - link：https://blog.csdn.net/xiaoyu4009/article/details/46426667
  - 简单来说就是 根据关键字来找内容
  - 为什么称为倒呢？从原文中遍历去找关键字，这种找法称为正。相对于这种，从关键字找出相应的位置就叫做倒
- 而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
- 减少时间代价较大/性能下降较大 的磁盘IO操作的次数
## 什么是索引
- 索引是是帮助数据库高效获取数据的数据结构。是一种特殊的文件(会占物理空间的。InnoDB数据表上的索引是表空间的一个组成部分)，它包含一个表中某些列的值（建立索引的列）以及记录对应的地址。
- 索引是一种数据结构(后面会讲索引的数据结构）。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 为什么要使用索引
- 数据库的一个重要功能就是查询，一个查询需要遍历全表去扫描，而随着数据量越来越大，所花费的时间就会越来越长。而索引是有序排列的，所以可以加速查询
- select name，... from tbl_name where name="xxx"; 数据库就需要遍历全表，对每条数据来比对name是不是xxx，而当我们对name建立索引时，在查找时就能迅速定位到xxx在索引中的记录，进而能获取到表中对应的记录。

## 索引的使用场景
- 一个字段上能建立多种索引，如果有多个，查询的时候会选一个较优的来作为检索的依据。（？怎么知道是最优呢？）
- 不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。？

- 查询
  - select * from tbl_a where field_a xxx; 当field_a上建立了索引时，使用该字段查询的效率会有明显的提升（数据量越大越明显）。
  - 索引覆盖
    - 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖
    - 因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- order_by 排序时
  - 将结果按照某个字段排序时，如果该字段没有建立索引，会使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。（从磁盘取数据是最影响性能的）
  - 如果建立了索引， 由于索引本身是有序的，可以直接按照索引的顺序和映射关系逐条取出数据就可以。
- join
  - 对join语句匹配关系（on）涉及的字段建立索引能够提高效率

## 索引的类型
- 主键索引
  - 一个表只能有一列是；值不允许为null；值不允许重复
- 唯一索引
  - 一个表能有多列是；值允许为null；值不允许重复
  - 分唯一索引与唯一组合索引（多列）
- 普通索引
  - 基本的索引类型，值允许为null；允许重复
- 全文索引 fulltext
  - link
    - https://blog.csdn.net/mrzhouxiaofei/article/details/79940958
    - https://blog.csdn.net/qq_18975791/article/details/102650479

  - 如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。
  - like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。
  - 对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。
  - 使用 `select * from tbl_name where MATCH(建立全文索引的列) AGAINST(关键词)`

## 索引的数据结构（b树，hash）
- 索引的数据结构和具体存储引擎的实现有关，基本上90%的人用的就是InnoDB了，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。InnoDB存储引擎的默认索引实现是B+树
- 通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
- B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持

### B树和B+树的查询流程
#### 请主要关注B+树，有疑惑先放放，不同的地方只用看下面有一小节写的
![B树索引的结构](https://images2017.cnblogs.com/blog/1184802/201709/1184802-20170912211249219-1576835998.png)
![B+树索引的结构](http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg)
- b+树的数据结构（真实结构是下图，但是是照着上面这个图讲的）
  - 浅蓝色的是一个磁盘块，每个磁盘块中包含几个数据项（深蓝色的）和指针（黄色）。如磁盘块1包含数据项17和35, 包含指针P1, P2, P3；P1表示小于17的磁盘块，P3表示大于35的磁盘块，P2表示在17和35之间的磁盘块。真实的数据项存在于叶子结点即磁盘块5,6,7,8,9,10,11中；非叶子节点不存储真实的数据(17,35这些并不真实存在数据表中，而是作为指引搜索方向的数据项存在非叶子节点当中）
- B树的搜索流程（主键索引）B+树也差不多
  - 如果要查找数据项29, 首先把磁盘块1加载到内存中，此时发生一次IO， 然后在内存中使用二分法查找确定29在17和35中，锁定磁盘块1的P2指针。（比较的时间相比加载时间可以忽略不计）。然后把磁盘块3加载到内存中，此时发生第二次IO，29在26和30之间，锁定P2指针。然后加载磁盘块8到内存中，此时发生第三次IO，内存中对这些数据（可能有很多）做二分查找找到29。查询结束， 总计3次磁盘IO。
  - 而真实的情况是3层的B+树可以存储上百万个数据，如果上百万的数据查找只需要三次IO，那么是非常快的
- 普通索引的查询方式
  - 普通索引关联的是id的地址，所以按主键查询，速度更快
  
### B+树索引的性质
- 索引要尽可能的小
  - 在查找中可以发现，当树的高度h越低，就能越快找到。假设数据量是N， 每个磁盘块中的数据个数是m， 则h=log(m+1)N. 而磁盘块的大小是固定的（等于一个磁盘页），则索引越小 每个磁盘块中的m就越大。
  - 正因为要减小数据的大小，所以把数据项放到了叶子节点，这样非叶子节点就能放更多的数据。防止数据过大导致退化成线性表。

- 最左匹配
  - 对组合索引（A B C），B+树会按照从左到右来建立搜索树。比如搜索(A_value, B_value, C_value)时，会先去比较A来确定搜索方向，如果有相同的再去比较B这样依次来得到匹配数据。但是如果搜索(B_value, C_value)时， B+树就不知道该去查哪个节点。因为搜索树是把name作为第一个比较因子，没有name就不知道去哪里查询。同样的(A_value, C_value)也只能把所有匹配A的给找到，然后在一个一个匹配C的数据。
  - 我定义了 A,B,C的组合索引，如果 我只传递了 A,B 能走索引吗？答案是能，因为最左侧原理

### 为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读 
- 由于程序的局部性原理，磁盘在读取数据的时候，即使要的东西很少，也会从目标位置向后多读取一些数据来返回。那么如果是有局部性原理的程序，这样做就相当于加速了磁盘IO（就不需要多吃读取时的寻道时间了，只需要旋转时间）
- 索引比较大的话，就不能一次从磁盘读取到内存中，每次只能读取一个磁盘页的数据。而平衡二叉树只是逻辑上的平衡，其物理实现是数组。所以在逻辑结构上相邻的节点在磁盘中可能会离的很远。就会造成多次IO；另一个方面，每次预读的数据也都没用上。
- 另一个方面是深度比较大，这样查找时就会有更多的比较和最占时间的磁盘IO
- 而B树的每个节点都可以存储很多关键字，并且节点的大小就是磁盘页的大小，每次读取刚好读取一个磁盘页，而正因为节点中的关键字多，所以树的深度就小，就有更少的磁盘IO。
- B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。所以虽然B树查询的次数比不上平衡二叉树，但最占用时间的磁盘IO小于平衡二叉树。
  
### B树和B+树的区别
- 最大的区别是内部节点是否包含值（即指向索引信息的指针），B树包含，B+树不包含；而两者的叶子节点都包含键和值
- 二者的查询次数也不都是稳定的，B+树都必须走到叶子节点，而B树有可能在内部节点就查到了，这也意味着同样的数据，有可能位置不一样如图![位置不一样](PDF中)

### 为什么是B+树而不是B树
- 先讲为什么索引越小越好
- B树的节点中不仅存储键值，还存储数据，而B+树的数据只在叶子节点中存储。这样非叶子节点中就能存储更多的键值，就能减小树的高度，提高树的阶数（使树变得更矮更胖）。使查询时有更少的磁盘IO
- B+树的数据是在叶子节点，并且叶子节点的数据是按顺序排列的。这使得在面对范围查询、排序查询、分组查找、去重查找时很有优势。例如在范围查询时，B+树只需要找到起始点数据的位置，就可以开始读取。而B树的数据是分散在各个节点的，读取了第一个后，后面的还需要再走一边查询流程。这是选用B+树最主要的原因
- 增删节点时的效率更高，因为B+树的叶子节点包含所有的数据，并且是有序排列的，这样可以提高增删的效率
### B树的好处：
  - 树的高度整体比B+树低（为什么，命名节点中存的数据少啊？）成功查询时和非成功查询都比B+树有利

## hash哈希索引
- MySQL使用哈希索引时， 主要是使用Hash算法（直接定址法， 平方取中、折叠法、除数取余法、随机数法）将索引字段转换成定长的Hash值，与这个字段对应的行指针一并存到Hash表对应位置；如果发生了Hash碰撞，会在对应的Hash值下以链表形式存储（然后根据里面存储的值是否相同来比对）
- 查找时调用一次hash函数就可获取到相应的键值，然后进行回表获得实际数据

## hash哈希索引 和 B+树索引
- 对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；其余的大部分场景，建议选择BTree索引，可以获得稳定且较好的查询速度
- hash索引在任何时候都需要回表；而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引的性能不稳定，有大量重复值的时候
- hash不支持范围查询、模糊查询

## 索引的基本原理
- 看下面的：为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读
- 索引的基本原理就是把无序的数据变为有序的
  - 把创建了索引的列的内容进行排序
  - 对排序结果生成倒排表
  - 在倒排表内容上拼上数据地址链
  - 在查询的时候，先拿到倒排表内容，然后在取出数据地址链，从而拿到具体数据

## 索引的算法
- 分为BTree算法和Hash算法
- BTee算法（默认）
  - 可以用于比较操作符，不以通配符开头的like操作符上；如果以通配符开头，或者没有使用常量，则不会使用索引，例如：`select * from tbl_name where name like '%jack'` # 以通配符开头；没有使用常量是什么情况？question_1
- Hash算法
  - Hash索引只适用于对等查找，只需一次IO就能定位数据。所以查找效率远高于BTree

## 索引设计的原则、创建索引的原则和需要注意的
- 最左匹配原则/最左前缀原则（在查询中，MySQL会从左到右匹配，直到遇见范围查询（>,<,between, like）就停止匹配）只对组合索引生效
  - `a=1 and b in xxx and c>2 and d=3` 如果组合索引是（a,b,c,d）,会先去比较a，然后比较b，然后比较c，因为c是范围查询，所以到这里就停止了；注意先去比较谁是按组合索引的顺序，而不是SQL里的顺序。所以应该把c放到组合索引的最后面
  - MySQL会自动优化条件查询（非范围查询），但如果组合索引前面的值没有出现在查询中，则后面的索引都不会用到
  - 应该把使用最频繁的放到左边，此外可以根据特例的查询或者表结构进行单独的调整。
  - [使用索引的场景](https://blog.csdn.net/qq_27500493/article/details/108149440)

- 适合索引的是出现在where子句中的，或者是join中的列
- 基数小的列不适合用索引，效果不明显
- 不要滥用索引，一是索引会占用磁盘空间（占用的比例是怎样的？），二是索引会影响更新表的速度，在更新表时，索引也会更新，甚至重构。索引列越多，这个时间就越长
- 使用短索引，如果需要对长字符串索引，应该制定一个前缀长度，这样能节省大量的磁盘空间。

- 定义有外键的字段一定要建立索引
- 经常作为查询条件的字段才适合建立索引
- 区分度不大的字段不适合建立索引（如性别，就男女未知三种则不适合）；经常更新的也不适合创建索引
- 对于查询中很少涉及的，有很多重复值的，不要建立索引， 为什么？
- 尽量选择扩展索引（假如a已经有索引，现在想建立（a, b）组合索引，只需要修改原来的索引就行）
- 对于定义为text、image和bit的数据类型的列不要建立索引
- 注意非空字段
  - MySQL中，还有null的列很难进行查询优化， 因为null使得索引，索引的统计，索引的比较运算更加复杂。应该指定列为notnull， 然后使用0、特殊值、空字符串来代替null值
  - 组合索引如果有一列包含null值，那么这一整列对组合索引都是无效的。
- 组合索引时，将各个差异度大的列放到组合索引的前面， 可以通过count函数查看字段的差异值`select count(distinct id) from Person;` 其实就是看里面不同值的个数
- 注意索引的长度
  - 索引的字段越小越好，因为数据库的存储是以页为单位的，一次IO读取一页，字段越小，这里面包含的索引值就越多，前面有
- 在查询中只会用到一次索引，假如where中用到了，orderby就不用（是按照SQL的执行顺序吗）
  
## 建立索引/删除索引
- create table时
  - `create table tbl_name (col_1_define, col_2_define, [keyname(col_1[, col2]), ] [fulltextkey(field1[, field2]),] [uniquekey(field1[, field2])])`
- 使用alter table 语句增加索引
  - `alter table tbl_name add index index_name (column_list);`
  - ALTERTABLE用来创建普通索引、UNIQUE索引或PRIMARYKEY索引。
  - 索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTERTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

- 使用CREATE INDEX命令创建
  - `CREATE INDEX index_name ON table_name(column_list);`
  - CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARYKEY索引）

- 删除索引
  - alter table 表名 drop KEY 索引名
  - 如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）,需要取消自增长再行删除：
    - alter table tbl_name modify id int, drop primarykey # 定义字段后删除
 
## 使用索引一定能提高查询的性能吗？
- 不一定，索引范围查询（INDEXRANGESCAN）适用于两种情况
  - 返回的数据小于表中记录的30%
  - 基于非唯一性索引的检索
- 索引查询在大多数情况下都比全表扫描要快，但同时也带来了一些代价
  - 索引需要空间存储，也需要定期维护，每当记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每次update、insert、delete语句需要额外付出4,5次的IO。
  - 不必要的索引反而会使查询反应时间变慢

## 索引的缺点 及 如何删除百万级别或以上的数据
- 关于索引
  - 索引是需要额外的维护成本的，他是一个独立存在的文件。在对数据进行插入、更新、删除的时候，索引也需要修改，这就带来的额外的IO，降低了更新数据的效率。
- 删除数据的速度适合建立的索引数量成正比的，所以删除数据的时候：
  - 先删除索引（3min）
  - 删除数据（2min）
  - 重新创建索引，因为少了很多数据所以大概只需要10min
  - 这样就大大小于直接删除的时间，更不用说删除失败的时候，一切的删除都会回滚。

## 前缀索引
- 默认的索引是使用全部的字段，我们可以使用字段的前几个字符来建立索引 `create index test_index on test (name(3));`
- 关键是前缀的标识度要高，另外一个是在于找到最有效的前缀长度
  - `select count(*)/count(distinctleft(password,prefixLen))`  通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

## 聚簇索引、非聚簇索引、辅助索引、索引覆盖、聚合索引
- 叶子节点中不包含整行数据的就是非聚簇索引（键是包含了索引的值 值是对应的主键的值）; 叶子节点存储了当前key值以及整行的数据 就是聚簇索引
- MySQL中只有主键是聚簇索引， 如果没有定义主键，就会把第一个非空的唯一索引作为聚簇索引，如果仍没有符合条件的唯一索引，会建立一个隐藏的非空索引来作为聚簇索引
- 当使用非聚簇索引查询非聚簇索引之外的字段时，就会发生回表
- 只有主键索引是聚簇索引，此外的所有都是非聚簇索引，在主键上建立的索引称为辅助索引，非聚簇索引都是辅助索引。
- 覆盖索引 查询语句所要求的字段全部命中了索引的现象，是使用组合索引来避免回表的一种策略
  - link：https://www.cnblogs.com/yanggb/p/11252966.html
```
在索引的叶子节点上，已经包含了要查询字段的信息
# 索引是a
select a from tbl_name where a xxx
# 或者是组合索引a、b、c
select a,b,c from tbl_name where a xx and b xx and c xxx
```
- 假如建立了组合索引（a,b,c）,会先按a进行排序，相同的按照b排序，b也相同的按照c排序；当进行查询的时候，此时的数据仅按照a严格有序，所以应首先使用a进行等值查询，对于查到的数据，是按b严格有序的，这时可以使用b来做索引查找，以此类推。因此建立组合索引时应注意索引列的顺序。

## 回表
- 当使用非聚簇索引查询聚簇索引之外的字段时，会先遍历非聚簇索引的索引树，然后找到这个数据所对应的主键值，然后去遍历主键索引树。这种遍历第二颗索引树的现象就称为回表
- 为什么非聚簇索引的叶子节点不包含整行数据的地址呢？因为包含整行数据地址的指针过大吗？可指针不应该只存储一个地址，是与目的地址所存的数据大小无关吗
  - 不是的 地址一般由 文件号+块号+块内偏移组成，大概10个字节
  - [链接](https://blog.csdn.net/moakun/article/details/81813994)
  - 另一个原因就是行地址发生变化的时候只需要修改聚簇索引里的行地址就好了
- B+树在满足聚簇索引和索引覆盖的情况下不需要回表
![回表的查询步骤](https://upload-images.jianshu.io/upload_images/4459024-a75e767d0198a6a4?imageMogr2/auto-orient/strip|imageView2/2/w/421/format/webp)

## 何时使用聚簇索引和非聚簇索引
- 主键列和外键列、列经常被分组和排序 都应该使用
- 频繁修改、更新的索引列 不应该使用聚簇索引， 应该使用非聚簇索引
- 返回某个范围的数据 应该使用聚簇索引，不应该使用非聚簇索引
- 一个或者极少的不同值，都不应该使用；小数量的不同值，应该使用聚簇索引，不应该使用非聚簇索引；大数量的不同值，不应该使用聚簇索引， 应该使用非聚簇索引。

## 表的优化
- 越小的数据类型和越简单的数据类型越好
  - 应该用内置的日期和时间数据类型，而不是字符串来存储时间；
  - 用整形数据存储IP地址。
