# link
  - local_doc
  - https://www.cnblogs.com/aspirant/p/9214485.html
  - [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
  - [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)
  - [浅谈算法和数据结构: 十 平衡查找树之B树，而这篇博文里有B树和B+树插入元素的过程GIF图，超赞，有助于对B树和B+树的理解！]()
  - [MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)
# 问题
- 索引如果是连贯的1,2,3....10, 那非叶子节点存储什么？
- BTree索引时，like中没有常量不会使用索引是啥意思？question_1
- 为什么 定义有外键的字段一定要建立索引？
- B树和B+树的区别就是B+树的内部结点只存放键，叶子节点同时存放键值。这里的键和值分别指的什么？
  - 键是索引的值，值是指向当前行的地址吗？还是当前行的数据？
  - 键是索引的值，值是一个指针（指向关键字具体信息的地址）来源于上面的链接[从B树、B+树、B*树谈到R 树]
  - 并不一定是数据行的地址，非聚簇索引是主键
- 回表到低是什么意思？是select内容是索引的内容吗？那为什么hash任何时候都要回表，而B+树在索引覆盖，聚簇索引情况下不需要回表呢？
- 为什么非聚簇索引的叶子节点不包含整行数据的地址呢？
# 索引的一些语法
```
# 建立普通索引 
alter table tbl_name add index field_name;
ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); # 普通组合索引

# 查看可用索引
explain select * from tbl_a wher field_a xxx # possible_key可用索引， key用来检索的索引

# 唯一索引
ALTER TABLE table_name ADD UNIQUE(column);创建唯一索引
ALTER TABLE table_name ADD UNIQUE(column1,column2);创建唯一组合索引

# 创建全文索引
ALTER TABLE table_name ADD FULLTEXT(column， column2);
```
# 索引的一些名词
- 键和索引等同
- 聚集索引和聚簇索引等同、辅助索引和非聚簇索引等同
- 随机检索和顺序检索
  - 随机检索就是查a，查d，下一个不一定是查啥
  - 顺序检索就是查a，查b（也可能是查c吧）就是虽然不连续，但是是有序的
- 索引覆盖
- 索引是有序的？
- 节点又被称为页，页的大小是固定的，InnoDB中页的大小默认是16KB
- B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”
- 扫库：遍历表 B+树方便扫库
- 倒排表
  - link：https://blog.csdn.net/xiaoyu4009/article/details/46426667
  - 简单来说就是 根据关键字来找内容
  - 为什么称为倒呢？从原文中遍历去找关键字，这种找法称为正。相对于这种，从关键字找出相应的位置就叫做倒
- 而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
- 减少时间代价较大/性能下降较大 的磁盘IO操作的次数
## 什么是索引
- 索引是是帮助数据库高效获取数据的数据结构。是一种特殊的文件(会占物理空间的。InnoDB数据表上的索引是表空间的一个组成部分)，它包含一个表中某些列的值（建立索引的列）以及记录对应的地址。
- 索引是一种数据结构(后面会讲索引的数据结构）。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 为什么要使用索引
- 数据库的一个重要功能就是查询，一个查询需要遍历全表去扫描，而随着数据量越来越大，所花费的时间就会越来越长。而索引是有序排列的，所以可以加速查询
- select name，... from tbl_name where name="xxx"; 数据库就需要遍历全表，对每条数据来比对name是不是xxx，而当我们对name建立索引时，在查找时就能迅速定位到xxx在索引中的记录，进而能获取到表中对应的记录。

## 索引的使用场景
- 一个字段上能建立多种索引，如果有多个，查询的时候会选一个较优的来作为检索的依据。（？怎么知道是最优呢？）
- 不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。？

- 查询
  - select * from tbl_a where field_a xxx; 当field_a上建立了索引时，使用该字段查询的效率会有明显的提升（数据量越大越明显）。
  - 索引覆盖
    - 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖
    - 因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- order_by 排序时
  - 将结果按照某个字段排序时，如果该字段没有建立索引，会使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。（从磁盘取数据是最影响性能的）
  - 如果建立了索引， 由于索引本身是有序的，可以直接按照索引的顺序和映射关系逐条取出数据就可以。
- join
  - 对join语句匹配关系（on）涉及的字段建立索引能够提高效率

## 索引的类型
- 主键索引
  - 一个表只能有一列是；值不允许为null；值不允许重复
- 唯一索引
  - 一个表能有多列是；值允许为null；值不允许重复
  - 分唯一索引与唯一组合索引（多列）
- 普通索引
  - 基本的索引类型，值允许为null；允许重复
- 全文索引 fulltext
  - link
    - https://blog.csdn.net/mrzhouxiaofei/article/details/79940958
    - https://blog.csdn.net/qq_18975791/article/details/102650479

  - 如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。
  - like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。
  - 对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。
  - 使用 `select * from tbl_name where MATCH(建立全文索引的列) AGAINST(关键词)`

## 索引的数据结构（b树，hash）
- 索引的数据结构和具体存储引擎的实现有关，基本上90%的人用的就是InnoDB了，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。InnoDB存储引擎的默认索引实现是B+树
- 通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
- B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持

### B树和B+树的查询流程
#### 请主要关注B+树，有疑惑先放放，不同的地方只用看下面有一小节写的
![B树索引的结构](https://images2017.cnblogs.com/blog/1184802/201709/1184802-20170912211249219-1576835998.png)
![B+树索引的结构](http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg)
- b+树的数据结构（真实结构是下图，但是是照着上面这个图讲的）
  - 浅蓝色的是一个磁盘块，每个磁盘块中包含几个数据项（深蓝色的）和指针（黄色）。如磁盘块1包含数据项17和35, 包含指针P1, P2, P3；P1表示小于17的磁盘块，P3表示大于35的磁盘块，P2表示在17和35之间的磁盘块。真实的数据项存在于叶子结点即磁盘块5,6,7,8,9,10,11中；非叶子节点不存储真实的数据(17,35这些并不真实存在数据表中，而是作为指引搜索方向的数据项存在非叶子节点当中）
- B树的搜索流程（主键索引）B+树也差不多
  - 如果要查找数据项29, 首先把磁盘块1加载到内存中，此时发生一次IO， 然后在内存中使用二分法查找确定29在17和35中，锁定磁盘块1的P2指针。（比较的时间相比加载时间可以忽略不计）。然后把磁盘块3加载到内存中，此时发生第二次IO，29在26和30之间，锁定P2指针。然后加载磁盘块8到内存中，此时发生第三次IO，内存中对这些数据（可能有很多）做二分查找找到29。查询结束， 总计3次磁盘IO。
  - 而真实的情况是3层的B+树可以存储上百万个数据，如果上百万的数据查找只需要三次IO，那么是非常快的
- 普通索引的查询方式
  - 普通索引关联的是id的地址，所以按主键查询，速度更快
  
### B+树索引的性质
- 索引要尽可能的小
  - 在查找中可以发现，当树的高度h越低，就能越快找到。假设数据量是N， 每个磁盘块中的数据个数是m， 则h=log(m+1)N. 而磁盘块的大小是固定的（等于一个磁盘页），则索引越小 每个磁盘块中的m就越大。
  - 正因为要减小数据的大小，所以把数据项放到了叶子节点，这样非叶子节点就能放更多的数据。防止数据过大导致退化成线性表。

- 最左匹配
  - 对复合索引（A B C），B+树会按照从左到右来建立搜索树。比如搜索(A_value, B_value, C_value)时，会先去比较A来确定搜索方向，如果有相同的再去比较B这样依次来得到匹配数据。但是如果搜索(B_value, C_value)时， B+树就不知道该去查哪个节点。因为搜索树是把name作为第一个比较因子，没有name就不知道去哪里查询。同样的(A_value, C_value)也只能把所有匹配A的给找到，然后在一个一个匹配C的数据。
  - 我定义了 A,B,C的联合索引，如果 我只传递了 A,B 能走索引吗？答案是能，因为最左侧原理

### 为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读 
- 由于程序的局部性原理，磁盘在读取数据的时候，即使要的东西很少，也会从目标位置向后多读取一些数据来返回。那么如果是有局部性原理的程序，这样做就相当于加速了磁盘IO（就不需要多吃读取时的寻道时间了，只需要旋转时间）
- 索引比较大的话，就不能一次从磁盘读取到内存中，每次只能读取一个磁盘页的数据。而平衡二叉树只是逻辑上的平衡，其物理实现是数组。所以在逻辑结构上相邻的节点在磁盘中可能会离的很远。就会造成多次IO；另一个方面，每次预读的数据也都没用上。
- 另一个方面是深度比较大，这样查找时就会有更多的比较和最占时间的磁盘IO
- 而B树的每个节点都可以存储很多关键字，并且节点的大小就是磁盘页的大小，每次读取刚好读取一个磁盘页，而正因为节点中的关键字多，所以树的深度就小，就有更少的磁盘IO。
- B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。所以虽然B树查询的次数比不上平衡二叉树，但最占用时间的磁盘IO小于平衡二叉树。
  
### B树和B+树的区别
- 最大的区别是内部节点是否包含值（即指向索引信息的指针），B树包含，B+树不包含；而两者的叶子节点都包含键和值
- 二者的查询次数也不都是稳定的，B+树都必须走到叶子节点，而B树有可能在内部节点就查到了，这也意味着同样的数据，有可能位置不一样如图![位置不一样](PDF中)

### 为什么是B+树而不是B树
- 先讲为什么索引越小越好
- B树的节点中不仅存储键值，还存储数据，而B+树的数据只在叶子节点中存储。这样非叶子节点中就能存储更多的键值，就能减小树的高度，提高树的阶数（使树变得更矮更胖）。使查询时有更少的磁盘IO
- B+树的数据是在叶子节点，并且叶子节点的数据是按顺序排列的。这使得在面对范围查询、排序查询、分组查找、去重查找时很有优势。例如在范围查询时，B+树只需要找到起始点数据的位置，就可以开始读取。而B树的数据是分散在各个节点的，读取了第一个后，后面的还需要再走一边查询流程。这是选用B+树最主要的原因
- 增删节点时的效率更高，因为B+树的叶子节点包含所有的数据，并且是有序排列的，这样可以提高增删的效率
### B树的好处：
  - 树的高度整体比B+树低（为什么，命名节点中存的数据少啊？）成功查询时和非成功查询都比B+树有利

## hash哈希索引
- MySQL使用哈希索引时， 主要是使用Hash算法（直接定址法， 平方取中、折叠法、除数取余法、随机数法）将索引字段转换成定长的Hash值，与这个字段对应的行指针一并存到Hash表对应位置；如果发生了Hash碰撞，会在对应的Hash值下以链表形式存储（然后根据里面存储的值是否相同来比对）
- 查找时调用一次hash函数就可获取到相应的键值，然后进行回表获得实际数据

## hash哈希索引 和 B+树索引
- 对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；其余的大部分场景，建议选择BTree索引，可以获得稳定且较好的查询速度
- hash索引在任何时候都需要回表；而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引的性能不稳定，有大量重复值的时候
- hash不支持范围查询、模糊查询

## 索引的基本原理
- 看下面的：为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读
- 索引的基本原理就是把无序的数据变为有序的
  - 把创建了索引的列的内容进行排序
  - 对排序结果生成倒排表
  - 在倒排表内容上拼上数据地址链
  - 在查询的时候，先拿到倒排表内容，然后在取出数据地址链，从而拿到具体数据

## 索引的算法
- 分为BTree算法和Hash算法
- BTee算法（默认）
  - 可以用于比较操作符，不以通配符开头的like操作符上；如果以通配符开头，或者没有使用常量，则不会使用索引，例如：`select * from tbl_name where name like '%jack'` # 以通配符开头；没有使用常量是什么情况？question_1
- Hash算法
  - Hash索引只适用于对等查找，只需一次IO就能定位数据。所以查找效率远高于BTree

## 索引设计的原则、创建索引的原则和需要注意的
- 最左匹配原则/最左前缀原则（在查询中，MySQL会从左到右匹配，直到遇见范围查询（>,<,between, like）就停止匹配）只对组合索引生效
  - `a=1 and b in xxx and c>2 and d=3` 如果组合索引是（a,b,c,d）,会先去比较a，然后比较b，然后比较c，因为c是范围查询，所以到这里就停止了；注意先去比较谁是按组合索引的顺序，而不是SQL里的顺序。所以应该把c放到组合索引的最后面
  - MySQL会自动优化条件查询（非范围查询），但如果组合索引前面的值没有出现在查询中，则后面的索引都不会用到
  - 应该把使用最频繁的放到左边，此外可以根据特例的查询或者表结构进行单独的调整。
  - [使用索引的场景](https://blog.csdn.net/qq_27500493/article/details/108149440)

- 适合索引的是出现在where子句中的，或者是join中的列
- 基数小的列不适合用索引，效果不明显
- 不要滥用索引，一是索引会占用磁盘空间（占用的比例是怎样的？），二是索引会影响更新表的速度，在更新表时，索引也会更新，甚至重构。索引列越多，这个时间就越长
- 使用短索引，如果需要对长字符串索引，应该制定一个前缀长度，这样能节省大量的磁盘空间。

- 定义有外键的字段一定要建立索引
- 经常作为查询条件的字段才适合建立索引
- 区分度不大的字段不适合建立索引（如性别，就男女未知三种则不适合）；经常更新的也不适合创建索引
- 对于查询中很少涉及的，有很多重复值的，不要建立索引， 为什么？
- 尽量选择扩展索引（假如a已经有索引，现在想建立（a, b）组合索引，只需要修改原来的索引就行）
- 对于定义为text、image和bit的数据类型的列不要建立索引
- 注意非空字段
  - MySQL中，还有null的列很难进行查询优化， 因为null使得索引，索引的统计，索引的比较运算更加复杂。应该指定列为notnull， 然后使用0、特殊值、空字符串来代替null值
  - 复合索引如果有一列包含null值，那么这一整列对复合索引都是无效的。
- 联合索引时，将各个差异度大的列放到联合索引的前面， 可以通过count函数查看字段的差异值`select count(distinct id) from Person;` 其实就是看里面不同值的个数
- 注意索引的长度
  - 索引的字段越小越好，因为数据库的存储是以页为单位的，一次IO读取一页，字段越小，这里面包含的索引值就越多，前面有
- 在查询中只会用到一次索引，假如where中用到了，orderby就不用（是按照SQL的执行顺序吗）
  
## 建立索引/删除索引
- create table时
  - `create table tbl_name (col_1_define, col_2_define, [keyname(col_1[, col2]), ] [fulltextkey(field1[, field2]),] [uniquekey(field1[, field2])])`
- 使用alter table 语句增加索引
  - `alter table tbl_name add index index_name (column_list);`
  - ALTERTABLE用来创建普通索引、UNIQUE索引或PRIMARYKEY索引。
  - 索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTERTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

- 使用CREATE INDEX命令创建
  - `CREATE INDEX index_name ON table_name(column_list);`
  - CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARYKEY索引）

- 删除索引
  - alter table 表名 drop KEY 索引名
  - 如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）,需要取消自增长再行删除：
    - alter table tbl_name modify id int, drop primarykey # 定义字段后删除
 
## 使用索引一定能提高查询的性能吗？
- 不一定，索引范围查询（INDEXRANGESCAN）适用于两种情况
  - 返回的数据小于表中记录的30%
  - 基于非唯一性索引的检索
- 索引查询在大多数情况下都比全表扫描要快，但同时也带来了一些代价
  - 索引需要空间存储，也需要定期维护，每当记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每次update、insert、delete语句需要额外付出4,5次的IO。
  - 不必要的索引反而会使查询反应时间变慢

## 索引的缺点 及 如何删除百万级别或以上的数据
- 关于索引
  - 索引是需要额外的维护成本的，他是一个独立存在的文件。在对数据进行插入、更新、删除的时候，索引也需要修改，这就带来的额外的IO，降低了更新数据的效率。
- 删除数据的速度适合建立的索引数量成正比的，所以删除数据的时候：
  - 先删除索引（3min）
  - 删除数据（2min）
  - 重新创建索引，因为少了很多数据所以大概只需要10min
  - 这样就大大小于直接删除的时间，更不用说删除失败的时候，一切的删除都会回滚。

## 前缀索引
- 默认的索引是使用全部的字段，我们可以使用字段的前几个字符来建立索引 `create index test_index on test (name(3));`
- 关键是前缀的标识度要高，另外一个是在于找到最有效的前缀长度
  - `select count(*)/count(distinctleft(password,prefixLen))`  通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

## 聚簇索引、非聚簇索引、辅助索引、覆盖索引、聚合索引
- 叶子节点中不包含整行数据的就是非聚簇索引（键是包含了索引的值 值是对应的主键的值）; 叶子节点存储了当前key值以及整行的数据 就是聚簇索引
- MySQL中只有主键是聚簇索引， 如果没有定义主键，就会把第一个非空的唯一索引作为聚簇索引，如果仍没有符合条件的唯一索引，会建立一个隐藏的非空索引来作为聚簇索引
- 当使用非聚簇索引查询非聚簇索引之外的字段时，就会发生回表
- 只有主键索引是聚簇索引，此外的所有都是非聚簇索引，在主键上建立的索引称为辅助索引，非聚簇索引都是辅助索引。
- 覆盖索引 查询语句所要求的字段全部命中了索引
```
在索引的叶子节点上，已经包含了要查询字段的信息
# 索引是a
select a from tbl_name where a xxx
# 或者是组合索引a、b、c
select a,b,c from tbl_name where a xx and b xx and c xxx
```
- 假如建立了联合索引（a,b,c）,会先按a进行排序，相同的按照b排序，b也相同的按照c排序；当进行查询的时候，此时的数据仅按照a严格有序，所以应首先使用a进行等值查询，对于查到的数据，是按b严格有序的，这时可以使用b来做索引查找，以此类推。因此建立联合索引时应注意索引列的顺序。

## 回表
- 当使用非聚簇索引查询聚簇索引之外的字段时，会先遍历非聚簇索引的索引树，然后找到这个数据所对应的主键值，然后去遍历主键索引树。这种遍历第二颗索引树的现象就称为回表
- 为什么非聚簇索引的叶子节点不包含整行数据的地址呢？因为包含整行数据地址的指针过大吗？可指针不应该只存储一个地址，是与目的地址所存的数据大小无关吗
- B+树在满足聚簇索引和索引覆盖的情况下不需要回表
![回表的查询步骤](https://upload-images.jianshu.io/upload_images/4459024-a75e767d0198a6a4?imageMogr2/auto-orient/strip|imageView2/2/w/421/format/webp)

## 何时使用聚簇索引和非聚簇索引
- 主键列和外键列、列经常被分组和排序 都应该使用
- 频繁修改、更新的索引列 不应该使用聚簇索引， 应该使用非聚簇索引
- 返回某个范围的数据 应该使用聚簇索引，不应该使用非聚簇索引
- 一个或者极少的不同值，都不应该使用；小数量的不同值，应该使用聚簇索引，不应该使用非聚簇索引；大数量的不同值，不应该使用聚簇索引， 应该使用非聚簇索引。

## 表的优化
- 越小的数据类型和越简单的数据类型越好
  - 应该用内置的日期和时间数据类型，而不是字符串来存储时间；
  - 用整形数据存储IP地址。
