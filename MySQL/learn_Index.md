# link
  - local_doc
  - https://www.cnblogs.com/aspirant/p/9214485.html
# 问题
- 索引如果是连贯的1,2,3....10, 那非叶子节点存储什么？
## 索引的一些语法
```
# 建立普通索引 
alter table tbl_name add index field_name;
ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); # 普通组合索引

# 查看可用索引
explain select * from tbl_a wher field_a xxx # possible_key可用索引， key用来检索的索引

# 唯一索引
ALTER TABLE table_name ADD UNIQUE(column);创建唯一索引
ALTER TABLE table_name ADD UNIQUE(column1,column2);创建唯一组合索引

# 创建全文索引
ALTER TABLE table_name ADD FULLTEXT(column， column2);
```
## 索引的一些名词
- 索引覆盖
- 索引是有序的？
- 节点又被称为页，页的大小是固定的，InnoDB中页的大小默认是16KB
- B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”
  
## 什么是索引
- 索引是是帮助数据库高效获取数据的数据结构。是一种特殊的文件(会占物理空间的。InnoDB数据表上的索引是表空间的一个组成部分)，它包含一个表中某些列的值（建立索引的列）以及记录对应的地址。
- 索引是一种数据结构(后面会讲索引的数据结构）。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

## 为什么要使用索引
- 数据库的一个重要功能就是查询，一个查询需要遍历全表去扫描，而随着数据量越来越大，所花费的时间就会越来越长。而索引是有序排列的，所以可以加速查询
- select name，... from tbl_name where name="xxx"; 数据库就需要遍历全表，对每条数据来比对name是不是xxx，而当我们对name建立索引时，在查找时就能迅速定位到xxx在索引中的记录，进而能获取到表中对应的记录。

## 索引的使用场景
- 一个字段上能建立多种索引，如果有多个，查询的时候会选一个较优的来作为检索的依据。（？怎么知道是最优呢？）
- 不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。？

- 查询
  - select * from tbl_a where field_a xxx; 当field_a上建立了索引时，使用该字段查询的效率会有明显的提升（数据量越大越明显）。
  - 索引覆盖
    - 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖
    - 因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
- order_by 排序时
  - 将结果按照某个字段排序时，如果该字段没有建立索引，会使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。（从磁盘取数据是最影响性能的）
  - 如果建立了索引， 由于索引本身是有序的，可以直接按照索引的顺序和映射关系逐条取出数据就可以。
- join
  - 对join语句匹配关系（on）涉及的字段建立索引能够提高效率


## 索引的类型
- 主键索引
  - 一个表只能有一列是；值不允许为null；值不允许重复
- 唯一索引
  - 一个表能有多列是；值允许为null；值不允许重复
  - 分唯一索引与唯一组合索引（多列）
- 普通索引
  - 基本的索引类型，值允许为null；允许重复
- 全文索引 fulltext
  - link
    - https://blog.csdn.net/mrzhouxiaofei/article/details/79940958
    - https://blog.csdn.net/qq_18975791/article/details/102650479
    - [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
    - [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)
    - [浅谈算法和数据结构: 十 平衡查找树之B树，而这篇博文里有B树和B+树插入元素的过程GIF图，超赞，有助于对B树和B+树的理解！]()
    - [MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)
  - 如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。
  - like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。
  - 对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。
  - 使用 `select * from tbl_name where MATCH(建立全文索引的列) AGAINST(关键词)`

## 索引的数据结构（b树，hash）
- 索引的数据结构和具体存储引擎的实现有关，基本上90%的人用的就是InnoDB了，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。InnoDB存储引擎的默认索引实现是B+树
- 通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
- B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持
### 哈希索引和B+树索引
- 对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；
- 其余的大部分场景，建议选择BTree索引
### B+树的查询流程
![B+树索引的结构](https://images2017.cnblogs.com/blog/1184802/201709/1184802-20170912211249219-1576835998.png)
- b+树的数据结构
  - 浅蓝色的是一个磁盘块，每个磁盘块中包含几个数据项（深蓝色的）和指针（黄色）。如磁盘块1包含数据项17和35, 包含指针P1, P2, P3；P1表示小于17的磁盘块，P3表示大于35的磁盘块，P2表示在17和35之间的磁盘块。真实的数据项存在于叶子结点即磁盘块5,6,7,8,9,10,11中；非叶子节点不存储真实的数据(17,35这些并不真实存在数据表中，而是作为指引搜索方向的数据项存在非叶子节点当中）
- B+树的搜索流程
  - 如果要查找数据项29, 首先把磁盘块1加载到内存中，此时发生一次IO， 然后在内存中使用二分法查找确定29在17和35中，锁定磁盘块1的P2指针。（比较的时间相比加载时间可以忽略不计）。然后把磁盘块3加载到内存中，此时发生第二次IO，29在26和30之间，锁定P2指针。然后加载磁盘块8到内存中，此时发生第三次IO，内存中对这些数据（可能有很多）做二分查找找到29。查询结束， 总计3次磁盘IO。
  - 而真实的情况是3层的B+树可以存储上百万个数据，如果上百万的数据查找只需要三次IO，那么是非常快的

### B+树索引的性质
- 索引要尽可能的小
  - 在查找中可以发现，当树的高度h越低，就能越快找到。假设数据量是N， 每个磁盘块中的数据个数是m， 则h=log(m+1)N. 而磁盘块的大小是固定的（等于一个磁盘页），则索引越小 每个磁盘块中的m就越大。
  - 正因为要减小数据的大小，所以把数据项放到了叶子节点，这样非叶子节点就能放更多的数据。防止数据过大导致退化成线性表。

- 最左匹配
  - 对复合索引（A B C），B+树会按照从左到右来建立搜索树。比如搜索(A_value, B_value, C_value)时，会先去比较A来确定搜索方向，如果有相同的再去比较B这样依次来得到匹配数据。但是如果搜索(B_value, C_value)时， B+树就不知道该去查哪个节点。因为搜索树是把name作为第一个比较因子，没有name就不知道去哪里查询。同样的(A_value, C_value)也只能把所有匹配A的给找到，然后在一个一个匹配C的数据。
  - 我定义了 A,B,C的联合索引，如果 我只传递了 A,B 能走索引吗？答案是能，因为最左侧原理

### 为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读
- 由于程序的局部性原理，磁盘在读取数据的时候，即使要的东西很少，也会从目标位置向后多读取一些数据来返回。那么如果是有局部性原理的程序，这样做就相当于加速了磁盘IO（就不需要多吃读取时的寻道时间了，只需要旋转时间）
- 索引比较大的话，就不能一次从磁盘读取到内存中，每次只能读取一个磁盘页的数据。而平衡二叉树只是逻辑上的平衡，其物理实现是数组。所以在逻辑结构上相邻的节点在磁盘中可能会离的很远。就会造成多次IO；另一个方面，每次预读的数据也都没用上。
- 另一个方面是深度比较大，这样查找时就会有更多的比较和最占时间的磁盘IO
- 而B树的每个节点都可以存储很多关键字，并且节点的大小就是磁盘页的大小，每次读取刚好读取一个磁盘页，而正因为节点中的关键字多，所以树的深度就小，就有更少的磁盘IO。
- B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。所以虽然B树查询的次数比不上平衡二叉树，但最占用时间的磁盘IO小于平衡二叉树。

### 为什么是B+树而不是B树
- B树的节点中不仅存储键值，还存储数据，而B+树的数据只在叶子节点中存储。这样非叶子节点中就能存储更多的键值，就能减小树的高度，提高树的阶数（使树变得更矮更胖）。使查询时有更少的磁盘IO
- B+树的数据是存在叶子节点，并且叶子节点的数据是按顺序排列的。这使得在面对范围查询、排序查询、分组查找、去重查找时很有优势。例如在范围查询时，B+树只需要找到起始点数据的位置，就可以开始读取。而B树的数据是分散在各个节点的，读取了第一个后，后面的还需要再走一边查询流程。这是选用B+树最主要的原因
- B树的好处：
  - 树的高度整体比B+树低（为什么，命名节点中存的数据少啊？）成功查询时和非成功查询都比B+树有利

## 使用索引的注意事项
- 不要滥用索引
  - 索引会占用磁盘空间（占用的比例是怎样的？）
  - 索引会降低插入更新的速度
- 避免索引列为null，因为含有null的列使得索引建立和运算很复杂。
  - 复合索引如果有一列包含null值，那么这一整列对复合索引都是无效的。
- 在查询中只会用到一次索引，假如where中用到了，orderby就不用（是按照SQL的执行顺序吗）
- `like %aaa%`不会使用索引，而`like aaa%`可以使用索引（因为最左匹配吗）

## 表的优化
- 越小的数据类型和越简单的数据类型越好
  - 应该用内置的日期和时间数据类型，而不是字符串来存储时间；
  - 用整形数据存储IP地址。
