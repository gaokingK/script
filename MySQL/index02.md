## 索引的数据结构（b树，hash）
- 索引的数据结构和具体存储引擎的实现有关，基本上90%的人用的就是InnoDB了，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。InnoDB存储引擎的默认索引实现是B+树
- 通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
- B树索引是Mysql数据库中使用频繁的索引类型，基本所有存储引擎都支持
- (主要关注B树和B+树）使用的数据结构主要有：二叉树（BST），平衡二叉树（AVL）、红黑树(R-B Tree)、平衡多路查找树（B-Tree）、B+Tree
  - link:https://juejin.cn/post/7032308521400188965
  - 二叉树：
    - 因为二叉树在极端情况下会退化成线性表，所以才有了平衡二叉树
    - 因为插入和删除操作会进行大量的平衡度计算，需要对节点进行频繁的旋转，所以有了红黑树，红黑树是弱平衡二叉树
    - 红黑树以牺牲严格的高度平衡的优越性为代价，只要求部分的达到平衡要求，结合节点的变色，减低了旋转的次数，从而提高了性能，他能以O(log2N)的复杂度进行插入、删除、修改操作，此外他的任何不平衡都会在三次旋转内解决
    - 别的优点回来再讲
  - 多叉树
    - 因为二叉树势必会造成树的高度很高，在IO操作很耗时的前提下，使用二叉树作为索引结构会大大降低查询的效率，所以多个节点（多叉）的B-Tree、B+Tree就出现了
    - 他俩的特性见下面


### B树和B+树的查询流程
#### 请主要关注B+树，有疑惑先放放，不同的地方只用看下面有一小节写的
![B树索引的结构](https://images2017.cnblogs.com/blog/1184802/201709/1184802-20170912211249219-1576835998.png)
![B+树索引的结构](http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg)
- b+树的数据结构（真实结构是下图，但是是照着上面这个图讲的）
  - 浅蓝色的是一个磁盘块，每个磁盘块中包含几个数据项（深蓝色的）和指针（黄色）。如磁盘块1包含数据项17和35, 包含指针P1, P2, P3；P1表示小于17的磁盘块，P3表示大于35的磁盘块，P2表示在17和35之间的磁盘块。真实的数据项存在于叶子结点即磁盘块5,6,7,8,9,10,11中；非叶子节点不存储真实的数据(17,35这些并不真实存在数据表中，而是作为指引搜索方向的数据项存在非叶子节点当中）
- B树的搜索流程（主键索引）B+树也差不多
  - 如果要查找数据项29, 首先把磁盘块1加载到内存中，此时发生一次IO， 然后在内存中使用二分法查找确定29在17和35中，锁定磁盘块1的P2指针。（比较的时间相比加载时间可以忽略不计）。然后把磁盘块3加载到内存中，此时发生第二次IO，29在26和30之间，锁定P2指针。然后加载磁盘块8到内存中，此时发生第三次IO，内存中对这些数据（可能有很多）做二分查找找到29。查询结束， 总计3次磁盘IO。
  - 而真实的情况是3层的B+树可以存储上百万个数据，如果上百万的数据查找只需要三次IO，那么是非常快的
- 普通索引的查询方式
  - 普通索引关联的是id的地址，所以按主键查询，速度更快
  
### B+树索引的性质
- 索引要尽可能的小
  - 在查找中可以发现，当树的高度h越低，就能越快找到。假设数据量是N， 每个磁盘块中的数据个数是m， 则h=log(m+1)N. 而磁盘块的大小是固定的（等于一个磁盘页），则索引越小 每个磁盘块中的m就越大。
  - 正因为要减小数据的大小，所以把数据项放到了叶子节点，这样非叶子节点就能放更多的数据。防止数据过大导致退化成线性表。

- 最左匹配
  - 对组合索引（A B C），B+树会按照从左到右来建立搜索树。比如搜索(A_value, B_value, C_value)时，会先去比较A来确定搜索方向，如果有相同的再去比较B这样依次来得到匹配数据。但是如果搜索(B_value, C_value)时， B+树就不知道该去查哪个节点。因为搜索树是把name作为第一个比较因子，没有name就不知道去哪里查询。同样的(A_value, C_value)也只能把所有匹配A的给找到，然后在一个一个匹配C的数据。
  - 我定义了 A,B,C的组合索引，如果 我只传递了 A,B 能走索引吗？答案是能，因为最左侧原理

### 为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读 
- 由于程序的局部性原理，磁盘在读取数据的时候，即使要的东西很少，也会从目标位置向后多读取一些数据来返回。那么如果是有局部性原理的程序，这样做就相当于加速了磁盘IO（就不需要多吃读取时的寻道时间了，只需要旋转时间）
- 索引比较大的话，就不能一次从磁盘读取到内存中，每次只能读取一个磁盘页的数据。而平衡二叉树只是逻辑上的平衡，其物理实现是数组。所以在逻辑结构上相邻的节点在磁盘中可能会离的很远。就会造成多次IO；另一个方面，每次预读的数据也都没用上。
- 另一个方面是深度比较大，这样查找时就会有更多的比较和最占时间的磁盘IO
- 而B树的每个节点都可以存储很多关键字，并且节点的大小就是磁盘页的大小，每次读取刚好读取一个磁盘页，而正因为节点中的关键字多，所以树的深度就小，就有更少的磁盘IO。
- B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。所以虽然B树查询的次数比不上平衡二叉树，但最占用时间的磁盘IO小于平衡二叉树。
  
### B树和B+树的区别
- 最大的区别是内部节点是否包含值（即指向索引信息的指针），B树包含，B+树不包含；而两者的叶子节点都包含键和值
- 二者的查询次数也不都是稳定的，B+树都必须走到叶子节点，而B树有可能在内部节点就查到了，这也意味着同样的数据，有可能位置不一样如图![位置不一样](PDF中)

### 为什么是B+树而不是B树
- 先讲为什么索引越小越好
- B树的节点中不仅存储键值，还存储数据，而B+树的数据只在叶子节点中存储。这样非叶子节点中就能存储更多的键值，就能减小树的高度，提高树的阶数（使树变得更矮更胖）。使查询时有更少的磁盘IO
- B+树的数据是在叶子节点，并且叶子节点的数据是按顺序排列的。这使得在面对范围查询、排序查询、分组查找、去重查找时很有优势。例如在范围查询时，B+树只需要找到起始点数据的位置，就可以开始读取。而B树的数据是分散在各个节点的，读取了第一个后，后面的还需要再走一边查询流程。这是选用B+树最主要的原因
- 增删节点时的效率更高，因为B+树的叶子节点包含所有的数据，并且是有序排列的，这样可以提高增删的效率
### B树的好处：
  - B树可以把数据放在内部节点中，假如把热点数据放在靠在根节点附近的位置就可以提高热点数据的查询速度，这种特性使得B树在特定数据的重复多次查询场景中更加高效
  - 树的高度整体比B+树低（为什么，命名节点中存的数据少啊？）成功查询时和非成功查询都比B+树有利 不是吧

## hash哈希索引
- MySQL使用哈希索引时， 主要是使用Hash算法（直接定址法， 平方取中、折叠法、除数取余法、随机数法）将索引字段转换成定长的Hash值，与这个字段对应的行指针一并存到Hash表对应位置；如果发生了Hash碰撞，会在对应的Hash值下以链表形式存储（然后根据里面存储的值是否相同来比对）
- 查找时调用一次hash函数就可获取到相应的键值，然后进行回表获得实际数据

## hash哈希索引 和 B+树索引
- 对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能快；其余的大部分场景，建议选择BTree索引，可以获得稳定且较好的查询速度
- hash索引在任何时候都需要回表；而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引的性能不稳定，有大量重复值的时候
- hash不支持范围查询、模糊查询

## 索引的基本原理
- 看下面的：为什么是b树而不是平衡二叉树 及 局部性原理与磁盘预读
- 索引的基本原理就是把无序的数据变为有序的
  - 把创建了索引的列的内容进行排序
  - 对排序结果生成倒排表
  - 在倒排表内容上拼上数据地址链
  - 在查询的时候，先拿到倒排表内容，然后在取出数据地址链，从而拿到具体数据

## 索引的算法
- 分为BTree算法和Hash算法
- BTee算法（默认）
  - 可以用于比较操作符，不以通配符开头的like操作符上；如果以通配符开头，或者没有使用常量，则不会使用索引，例如：`select * from tbl_name where name like '%jack'` # 以通配符开头；没有使用常量是什么情况？question_1
- Hash算法
  - Hash索引只适用于对等查找，只需一次IO就能定位数据。所以查找效率远高于BTree

## 索引设计的原则、创建索引的原则和需要注意的
- 最左匹配原则/最左前缀原则（在查询中，MySQL会从左到右匹配，直到遇见范围查询（>,<,between, like）就停止匹配）只对组合索引生效
  - `a=1 and b in xxx and c>2 and d=3` 
    - 如果组合索引是（a,b,c,d）,就会先去比较a，然后比较b，然后比较c，因为c是范围查询，所以到这里就停止了；
    - 如果组合索引是（a,b,d,c), 就会按a,b,d,c的顺序去查找，先去比较谁是按组合索引的顺序，而不是SQL里的顺序。所以应该把c放到组合索引的最后面
  - MySQL会自动优化条件查询（非范围查询）就比如上面的按照组合索引中a,b,d的顺序是怎么样，都可以用到索引，但如果组合索引前面的值没有出现在查询中，则后面的索引都不会用到
  - 应该把使用最频繁的放到左边，此外可以根据特例的查询或者表结构进行单独的调整。
  - [索引是否覆盖例子](https://blog.csdn.net/qq_27500493/article/details/108149440)
  - 索引跳跃扫描(Index Skip Scan)
    - link:https://juejin.cn/post/7127656601044910094
    - 简单来说就是如果数据库中某列只有少数的唯一值（比如age列），并且把这个列作为联合索引的第一列时，即使where中没有这个值，也会使用到联合索引
    - 但要明白，这是mysql的优化，其实不应该把差异度小的值作为索引的第一列

- 适合索引的是出现在where子句中的，或者是join中的列
- 基数小的列不适合用索引，效果不明显
- 不要滥用索引，一是索引会占用磁盘空间（占用的比例是怎样的？），二是索引会影响更新表的速度，在更新表时，索引也会更新，甚至重构。索引列越多，这个时间就越长
- 使用短索引，如果需要对长字符串索引，应该制定一个前缀长度，这样能节省大量的磁盘空间。

- 定义有外键的字段一定要建立索引
- 经常作为查询条件的字段才适合建立索引
- 区分度不大的字段不适合建立索引（如性别，就男女未知三种则不适合）；经常更新的也不适合创建索引
- 对于查询中很少涉及的，有很多重复值的，不要建立索引， 为什么？
- 尽量选择扩展索引（假如a已经有索引，现在想建立（a, b）组合索引，只需要修改原来的索引就行）
- 对于定义为text、image和bit的数据类型的列不要建立索引
- 注意非空字段
  - MySQL中，还有null的列很难进行查询优化， 因为null使得索引，索引的统计，索引的比较运算更加复杂。应该指定列为notnull， 然后使用0、特殊值、空字符串来代替null值
  - 组合索引如果有一列包含null值，那么这一整列对组合索引都是无效的。
- 组合索引时，将各个差异度大的列放到组合索引的前面， 可以通过count函数查看字段的差异值`select count(distinct id) from Person;` 其实就是看里面不同值的个数
- 注意索引的长度
  - 索引的字段越小越好，因为数据库的存储是以页为单位的，一次IO读取一页，字段越小，这里面包含的索引值就越多，前面有
- 在查询中只会用到一次索引，假如where中用到了，orderby就不用（是按照SQL的执行顺序吗）
  
## 建立索引/删除索引
- create table时
  - `create table tbl_name (col_1_define, col_2_define, [keyname(col_1[, col2]), ] [fulltextkey(field1[, field2]),] [uniquekey(field1[, field2])])`
- 使用alter table 语句增加索引
  - `alter table tbl_name add index index_name (column_list);`
  - ALTERTABLE用来创建普通索引、UNIQUE索引或PRIMARYKEY索引。
  - 索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTERTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

- 使用CREATE INDEX命令创建
  - `CREATE INDEX index_name ON table_name(column_list);`
  - CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARYKEY索引）

- 删除索引
  - alter table 表名 drop KEY 索引名
  - 如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）,需要取消自增长再行删除：
    - alter table tbl_name modify id int, drop primarykey # 定义字段后删除
 
## 使用索引一定能提高查询的性能吗？
- 不一定，索引范围查询（INDEXRANGESCAN）适用于两种情况
  - 返回的数据小于表中记录的30%
  - 基于非唯一性索引的检索
- 索引查询在大多数情况下都比全表扫描要快，但同时也带来了一些代价
  - 索引需要空间存储，也需要定期维护，每当记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每次update、insert、delete语句需要额外付出4,5次的IO。
  - 不必要的索引反而会使查询反应时间变慢

## 索引的缺点 及 如何删除百万级别或以上的数据
- 关于索引
  - 索引是需要额外的维护成本的，他是一个独立存在的文件。在对数据进行插入、更新、删除的时候，索引也需要修改，这就带来的额外的IO，降低了更新数据的效率。
- 删除数据的速度适合建立的索引数量成正比的，所以删除数据的时候：
  - 先删除索引（3min）
  - 删除数据（2min）
  - 重新创建索引，因为少了很多数据所以大概只需要10min
  - 这样就大大小于直接删除的时间，更不用说删除失败的时候，一切的删除都会回滚。

## 前缀索引
- 默认的索引是使用全部的字段，我们可以使用字段的前几个字符来建立索引 `create index test_index on test (name(3));`
- 关键是前缀的标识度要高，另外一个是在于找到最有效的前缀长度
  - `select count(*)/count(distinctleft(password,prefixLen))`  通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

## 聚簇索引、非聚簇索引、辅助索引、索引覆盖、聚合索引
- 写的是Innodb引擎的，MYIASM引擎的先不关注，关注了看链接：https://zhuanlan.zhihu.com/p/164519371
- 叶子节点中不包含整行数据的就是非聚簇索引（键是包含了索引的值 值是对应的主键的值）; 叶子节点存储了当前key值以及整行的数据 就是聚簇索引
- MySQL中只有主键是聚簇索引， 如果没有定义主键，就会把第一个非空的唯一索引作为聚簇索引，如果仍没有符合条件的唯一索引，会建立一个隐藏的非空索引来作为聚簇索引
- 当使用非聚簇索引查询非聚簇索引之外的字段时，就会发生回表
- 只有主键索引是聚簇索引，此外的所有都是非聚簇索引，在主键上建立的索引称为辅助索引，非聚簇索引都是辅助索引。
- 覆盖索引 查询语句所要求的字段(包括筛选条件和查询中的全部字段）全部命中了索引的现象，是使用组合索引来避免回表的一种策略
  - link：https://www.cnblogs.com/yanggb/p/11252966.html
  - 当 explain 的 extra包含using index，即为索引覆盖
  - ![查询语句是整行，筛选语句也不都在联合索引中，无论哪个条件都会触发回表，所以索引中没有using index;](../../imgs/covering_index.png)
  - ![这个为什么不先使用聚合索引呢？是索引长度的原因吗](../../imgs/comving_index02.png)
```
在索引的叶子节点上，已经包含了要查询字段的信息
# 索引是a
select a from tbl_name where a xxx
# 或者是组合索引a、b、c
select a,b,c from tbl_name where a xx and b xx and c xxx
```
- 假如建立了组合索引（a,b,c）,会先按a进行排序，相同的按照b排序，b也相同的按照c排序；当进行查询的时候，此时的数据仅按照a严格有序，所以应首先使用a进行等值查询，对于查到的数据，是按b严格有序的，这时可以使用b来做索引查找，以此类推。因此建立组合索引时应注意索引列的顺序。
### 聚簇索引和非聚簇索引区别
- 我们已经知道了聚簇索引和非聚簇索引的区分点是叶子节点是否包含整行的数据信息。但除此之外他们的叶子节点和非叶子节点在格式信息之外还有什么区别的
- 两种索引的非叶子节点都是只存储索引数据的，比如索引是id，那么非叶子节点内就只存储了id的值
- 聚簇索引的叶子节点存储了索引的值和对应行的整条数据（select * from table where id = 1 的时候，都是要去叶子节点拿数据的。）
- 非聚簇索引的叶子节点存储的是索引列的值和对应的主键信息比如索引是name,那么这个节点里的一个个单元里就是name和这个name对应的主键。一般情况下是先从非聚簇索引查到对应的主键值，在去聚簇索引里查找找到整行的值，一般情况下要查两次（覆盖索引除外）这也称为回表
###  回表
- 当使用非聚簇索引未发生索引覆盖的情况时，会先遍历非聚簇索引的索引树，然后找到这个数据所对应的主键值，然后去查找主键索引树。这种遍历第二颗索引树的现象就称为回表
- 为什么非聚簇索引的叶子节点不包含整行数据的地址呢？因为包含整行数据地址的指针过大吗？可指针不应该只存储一个地址，是与目的地址所存的数据大小无关吗
  - 不是的 地址一般由 文件号+块号+块内偏移组成，大概10个字节
  - [链接](https://blog.csdn.net/moakun/article/details/81813994)
  - 另一个原因就是行地址发生变化的时候只需要修改聚簇索引里的行地址就好了
- 回表不一定会影响性能
- B+树在满足聚簇索引和索引覆盖的情况下不需要回表
![回表的查询步骤](https://upload-images.jianshu.io/upload_images/4459024-a75e767d0198a6a4?imageMogr2/auto-orient/strip|imageView2/2/w/421/format/webp)

### 何时使用聚簇索引和非聚簇索引
- 主键列和外键列、列经常被分组和排序 都应该使用
- 频繁修改、更新的索引列 不应该使用聚簇索引， 应该使用非聚簇索引
- 返回某个范围的数据 应该使用聚簇索引，不应该使用非聚簇索引
- 一个或者极少的不同值，都不应该使用；小数量的不同值，应该使用聚簇索引，不应该使用非聚簇索引；大数量的不同值，不应该使用聚簇索引， 应该使用非聚簇索引。
### 为什么推荐使用自增型的整型主键而不是UUID
- 当创建表时未指定主键时，引擎会选择一个没有重复值的列建立索引，如果没有符合条件的列，会自动为表生成一个隐含字段作为主键，字段的类型为整型，那为什么不是uuid呢？
- uuid是字符串类型，整型比字符串占用更少的存储空间
- 在B+树中查找时需要和经过的节点值进行比较，整型的运算比字符串更快
- 自增的整型索引会在磁盘中连续存储，读取到的节点中的数据也是连续的，而uuid是随机产生的，同一节点中上下两行数据是分散的，这样不利于范围查询
- 在插入和删除时，uuid很容易触发B+树由于维持自身特性的重构，会消耗资源
## 表的优化
- 越小的数据类型和越简单的数据类型越好
  - 应该用内置的日期和时间数据类型，而不是字符串来存储时间；
  - 用整形数据存储IP地址。
