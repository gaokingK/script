# Python的GC机制是引用计数为主，标记清除和分代回收为辅 + 缓存机制[link](https://blog.csdn.net/qq_37388085/article/details/105852718)
### [弱引用和del](https://www.cnblogs.com/marsggbo/p/14831456.html)
### 关于对数据的称呼 如变量和数据对象的理解 如a = 1
    - 1 就是数据对象, a就是变量
    - 变量三要素 标识/类型/值 其中的值就是数据对象 标识是内存中的地址, 但这个地址存的是数据还是这个变量呢? 即数据对象和变量究竟对等不对等
    - 变量就是对象的别名, 我们可以通过变量找到对象,进而操纵对象
    - 标识是数据对象在内存中的地址
    - 在python总, 数据对象并不是只指向内存地址, 地址中存放值, 数据对象是一个结构体,当中有数据的值, 还有辅助的变量如维护引用计数的值
### 回收内存
    - 数据对象保存在内存当中,变量只是一个链接, 指向这个内存地址, 而变量赋值的本质是新的变量也指向内存中的相同地址, 只有当所有链接被删除后,这块内存才会被回收掉,内存中保存的数据就不存在了.
    - 内存回收也有假删除的情况, 只是删除变量的链接,然后新建东西的时候,使用这个变量原本指向的内存空间
    - Python垃圾回收的唯一必需属性是，它在所有引用都被删除之后发生
### 强引用和弱引用
    - 强引用和弱引用的区别就是引用的变化是否会改变引用计数
    - python中默认的就是强引用
    - 弱引用 即增加了引用,但并不会使数据对象的引用计数发生变化
    - 通过wreakref模块实现弱引用
### del
    - del 会是数据对象的引用技术减一, 而不是回收变量所指向的数据对象
    - del 作用在变量上,而不是作用在数据对象上 删除的是变量和数据的引用关系
    - del 做的和垃圾回收做的是一样的吗?
      - 大概是不一样的,del只是把这个引用关系给清空掉,清空调用,内存回收机制就被触发,先进行引用计数,然后如果这块内存中的引用值为0, 就会被回收
      - 在python总, 数据对象并不是只指向内存地址, 地址中存放值, 数据对象是一个结构体,当中有数据的值, 还有辅助的变量如维护引用计数的值
### __del__ 见learn_python_magic
### 一些需要注意的
- 由于多种原因，变量可以长期存在，例如传播性异常或模块自省可以使变量引用计数大于0。而且，变量可以是引用循环的一部分—启用垃圾回收的CPython大部分(但不是全部)中断此类循环，甚至只是周期性地中断
    - https://blog.csdn.net/weixin_39724009/article/details/110785744
# 未读完link: https://blog.csdn.net/weixin_39724009/article/details/110785744?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242