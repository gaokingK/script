# link:
- https://www.liujiangblog.com/course/python/83
# 非阻塞代码
- 非阻塞代码(也就是异步)指的是代码执行时程序或者执行线程挂起等待某个操作（特别是长时间操作如网络请求，I/O操作）这种代码允许在等待某个操作完成的同时，继续执行其他任务或者处理其他请求

### 阻塞 vs 非阻塞
- **阻塞操作**指的是某个操作必须完成，才能继续执行下一条指令。例如，当程序执行到一个文件读取操作时，它会停在那里，直到文件内容被完全读取。在这期间，程序不能做任何其他的事情。
- **非阻塞操作**，相反，意味着即使操作尚未完成，程序也可以继续执行下一个任务。这通常涉及异步I/O、协程、事件循环和回调函数等技术，以便在等待外部操作（如数据库交互或网络通信）时，可以释放资源处理其他任务。

### 非阻塞代码的优势
- **提高性能和响应速度**：由于执行线程不会因为等待操作而挂起，非阻塞I/O或非阻塞编程模型能够让程序在单个线程内高效地管理多个任务，从而提高应用的性能和响应速度。
- **更好的资源利用**：非阻塞编程减少了线程的需求，因为单个线程可以处理多个任务。这意味着更少的线程切换和更高效的CPU使用。
- **提升用户体验**：在用户界面（UI）编程和网络编程中，非阻塞代码可以避免应用程序在等待操作时冻结，从而提供更平滑和响应更快的用户体验。

### 实现非阻塞代码的技术
- **事件循环和异步I/O**：许多现代编程语言和框架，如Node.js、Python的asyncio库、JavaScript的Promise和async/await，都采用了事件循环机制来支持非阻塞I/O操作。
  - 事件循环用于管理和调度多个异步任务，让程序能够在单进程中实现非阻塞
- **回调函数**：在某些情况下，非阻塞操作通过注册回调函数来实现，当操作完成时，相应的回调函数被调用。
- 事件循环和回调函数共同构成了非阻塞编程的基础，使得程序能够高效地处理I/O密集型任务而不被阻塞。通过合理使用这两种机制，可以显著提升程序的性能和响应能力。
- **协程**：协程提供了一个更易于理解和维护的方式来编写非阻塞代码。它允许以看似同步的方式编写代码，而实际上却能在I/O操作等待时，释放线程来执行其他协程。
- await/async 这些高级特性在底层任然是基于事件循环和回调函数实现的，只不过提供了更简洁的语法

非阻塞编程模型在处理大量并发请求和高性能服务器应用程序中尤为重要，它能够显著提升效率和用户体验。然而，非阻塞编程也引入了额外的复杂性，特别是在错误处理和流程控制方面，这要求开发者需有较高的编程技巧。

# 抢占式调度和非抢占式调度
- 抢占式线程调度是一种操作系统的线程调度方式，这种方式会在cpu内核层面中断或者暂停当前cpu上执行的线程，将执行机会分配给其他线程；非抢占式线程调度是线程一旦获得了时间片，就会一直执行
- 抢占式线程调度是现代操作系统（如Windows、Linux等）广泛采用的线程调度方式，它通过强制中断机制保证系统处理的灵活性和高效性，但同时也因为频繁的上下文切换可能带来性能开销。
- 在抢占式调度中，操作系统的调度器会按照特定的算法（如轮转法、优先级调度法等）来决定哪个线程可以获得CPU时间，并且决策是在运行时动态发生的。每个线程都会获得一定的CPU时间片（time slice），一旦该时间片用完，如果其他线程等待执行，系统调度器就可以强行挂起当前线程，给其他线程分配CPU时间。
### 抢占式调度的关键特点：
时间片：系统为每个线程分配的执行时间。一旦时间片用完，不管任务是否完成，线程都会被挂起，以确保其他线程也有执行的机会。
公平性：每个线程都有获得CPU时间片的机会，这意味着即便是优先级较低的线程，也能定期获取执行时间。
上下文切换：切换当前运行线程至另一个线程的过程。包括保存当前线程的状态和恢复另一个线程的状态。
响应性：抢占式调度可以提高系统对实时事件的响应性，因为系统可以确保高优先级的线程可以及时获得处理器时间。
### 抢占式调度和非抢占式调度的比较：
- 抢占式：线程执行不能无限制进行。调度器可以强制从一个线程切换到另一个线程，从而实现系统资源的公平分配，并提高对共享资源访问的管理。
- 非抢占式（又称协作式）：线程一旦获得CPU，就会一直执行下去，直至线程自愿释放CPU（通常是因为I/O操作或达到预定的运行点）。这种非抢占方式可能导致低优先级或长时间任务阻塞系统，造成性能瓶颈。
# 零拷贝
在传统的数据传输中，数据可能在用户空间和内核态中多次复制，零拷贝是一种网络通信的优化技术，目的在于减少数据传输过程中数据拷贝的次数，提高数据传输效率，减小网络延迟

- 在讨论协程中的“零拷贝”（Zero-copy）之前，我们需要了解什么是“零拷贝”技术。零拷贝是一种计算机通信的优化技术，目标是在数据传输过程中减少CPU的拷贝操作，从而提高数据传输的效率，减少延迟，并提高系统的整体性能。在传统的数据传输操作中，数据可能需要在用户空间和内核空间之间多次复制，这些复制操作会增加CPU的负担和数据传输的延迟。
- 零拷贝技术试图通过减少这些不必要的数据复制来解决上述问题。在零拷贝技术的帮助下，数据可以直接在硬件（如网络接口）与应用程序之间传输，避免在内核空间和用户空间之间进行多余的复制。这样不仅减少了CPU的过度消耗，还降低了系统的上下文切换成本。
- 当我们把零拷贝概念应用到协程中时，目标仍然是提升性能和效率。协程是一种编程范式，可以更轻松地进行异步编程和并发处理。在协程框架下使用零拷贝技术，可以进一步减少协程之间数据传递的开销，特别是在高性能网络应用或文件处理应用中，这种优化显得尤为重要。例如，如果有协程负责从网络中读取数据，而另一个协程负责处理这些数据，零拷贝技术可以帮助有效地在这两个协程之间传递数据，而不会造成额外的复制开销。
- 结合协程的非阻塞特性和零拷贝技术，开发者可以构建出高效率、低延迟的应用程序。不过，需要注意的是，零拷贝技术的实现和优化通常涉及到操作系统级别的支持和网络/文件 IO的处理，因此在实际应用中需要具体问题具体分析。

# 我不理解的是明明多进程也是提高并发性能的一种手段，为什么异步显然更胜一筹呢
这个问题涉及到一些底层的计算机科学知识，主要是多进程和异步编程在处理并发任务上的不同特点和效率。让我们来深入探讨一下：

### 进程和线程

在并发编程中，进程（Process）和线程（Thread）是两种不同的执行单元：

1. **进程**：一个进程包含独立的内存空间和资源，每个进程之间是完全独立的。进程间通信（IPC）成本较高，但进程的崩溃不会影响其他进程。
2. **线程**：一个进程可以包含多个线程，线程共享进程的内存空间，因此线程之间的通信成本低。但是，一个线程的崩溃可能会影响同一进程内的其他线程。

### 多进程模型

在多进程模型中，每个请求可能会由一个独立的进程来处理：

- **优点**：
  - **隔离性好**：进程间隔离错误，一些错误不会影响到整个应用。
  - **充分利用多核**：可以利用多个 CPU 核心并行执行任务，从而提高 CPU 密集型任务的处理能力。

- **缺点**：
  - **资源消耗大**：每个进程都有独立的内存空间和资源，这会增加系统的内存和资源开销。
  - **上下文切换成本高**：进程间的上下文切换（CPU 在执行不同进程之间的切换）成本较高。
  - **启动开销大**：创建新进程的开销较大，会增加请求延迟。

### 异步模型

异步编程则采用事件驱动模型，通过单一的进程处理多个任务：

- **优点**：
  - **资源利用高效**：在 I/O 等待期间，CPU 可以切换去处理其他任务，提高资源利用率。
  - **上下文切换成本低**：由于所有操作在一个进程内完成，切换成本（主要是协程切换）较低。
  - **响应速度快**：异步编程模型可以更快响应大量并发请求，特别是 I/O 密集型任务。

- **缺点**：
  - **复杂性高**：需要掌握异步编程的概念，管理事件循环和回调，代码复杂度较高。
  - **适应性低**：对 CPU 密集型任务的优化不如多进程或多线程模型，对于这类任务异步模型收益不明显。

### 异步显然占优的原因

1. **降低 I/O 等待时间**：
   异步模型善于处理大量的 I/O 操作（如网络请求、文件操作等），在等待 I/O 操作完成时，不会阻塞整个进程，而是继续执行其他任务。从而能更高效地处理大量并发请求。

2. **上下文切换优化**：
   异步编程主要使用协程，而协程切换是在用户态完成的，不涉及内核态的上下文切换，开销非常小。而多进程模型的上下文切换涉及系统调用，开销相对较大。

3. **资源利用率**：
   异步模型下，一个进程可以处理大量并发请求，不需要为每个请求创建新的进程或线程，显著减少了内存和资源的消耗。而多进程模型则需要为每个进程分配独立的资源，系统的资源消耗更大。

### 总结

- **多进程模型** 适合 CPU 密集型任务，通过多进程来充分利用多核资源。主要优点是隔离性好，但是对于大量 I/O 密集型任务，效率会受到上下文切换成本和资源消耗的限制。
- **异步模型** 更适合 I/O 密集型任务，可以在一个进程中处理大量并发请求，响应速度快且资源利用率高。尽管异步编程复杂度高，但在应对高并发和 I/O 密集型任务时，优势显著。

因此，对于需要处理高并发和大量 I/O 操作的 web 应用，异步编程显然更胜一筹。

# 使用多进程的wsgi和单进程的asgi在面对高并发时的表现怎么样呢
WSGI（Web Server Gateway Interface）和 ASGI（Asynchronous Server Gateway Interface）是两个用于在 Python 中构建 web 应用的标准接口。它们在应对高并发时有不同的表现，很大程度上取决于它们的设计和实现方式。

### WSGI (多进程)

1. **同步阻塞模型**：
   WSGI 是一个同步的阻塞模型，这意味着每个请求都会阻塞该进程直到请求处理完成。这在处理 I/O 密集型任务（如数据库查询、文件读写等）时效率相对较低。

2. **多进程模型**：
   WSGI 应用通常运行在一个多进程环境中（例如，Gunicorn、uWSGI 等），每个进程独立处理请求。这种设计可以充分利用多核处理器，但进程间的上下文切换可能会带来一些开销。

3. **性能和可扩展性**：
   在面对高并发场景时，WSGI 应用需要通过增加更多的进程来处理更多的请求。这虽然可以提高处理能力，但扩展性有限，因为进程的资源消耗（如内存）较大，而且上下文切换成本较高。

### ASGI (单进程)

1. **异步非阻塞模型**：
   ASGI 是一个异步的非阻塞模型，可以同时处理多个请求而不需要等待每个请求的完成。这对处理 I/O 密集型任务非常高效，因为在进行 I/O 操作时，其他请求仍然可以继续处理。

2. **单进程 + 协程**：
   ASGI 应用通常运行在单进程环境中，但使用协程来处理并发请求（例如，使用 uvicorn、daphne 作为 ASGI 服务器）。这大大减少了进程间上下文切换的开销，以及资源的重复利用。

3. **性能和可扩展性**：
   在面对高并发场景时，ASGI 应用通过协程可以有效地处理更多的请求，具有更好的可扩展性和资源利用率。特别适合网络 I/O 密集型应用，如 WebSockets、实时通讯等。

### 比较

| 特性                     | WSGI (多进程)                               | ASGI (单进程)                           |
|--------------------------|---------------------------------------------|-----------------------------------------|
| **模型**                 | 同步阻塞                                   | 异步非阻塞                             |
| **并发处理方式**         | 多进程                                     | 单进程 + 协程                          |
| **适用场景**             | CPU 密集型任务，相对简单的HTTP请求         | I/O 密集型任务、需要高并发处理          |
| **性能**                 | 高并发处理能力有限，性能依赖于多进程        | 优秀的高并发处理能力，高效的资源利用    |
| **扩展性**               | 通过增加更多进程实现，受限于系统资源       | 通过异步处理实现，资源利用更高效        |
| **开发复杂度**           | 简单直接，便于理解                         | 需要理解异步编程模型，复杂度较高        |

### 实际选择

1. **WSGI** 更适合传统的 Web 应用，特别是那些主要处理 CPU 密集型任务或简单的 HTTP 请求的应用。
2. **ASGI** 更适合现代 web 应用，尤其是那些需要处理大量 I/O 操作、高并发连接（如 WebSocket、实时通讯）的应用。

在选择时，需要根据具体应用的需求和特性进行权衡。如果你的应用需要应对高度并发和 I/O 密集型任务，那么 ASGI 可能是更适合的选择。如果你的应用主要处理计算密集型任务且并发量较低，那么 WSGI 也能很好地满足需求。

# 异步可以使用多进程来再次提高负载能力吗
当然可以！异步编程与多进程组合使用可以进一步提高负载和并发处理能力。这种方法结合了异步编程和多进程的优点，充分利用系统资源，以应对更高的并发负载。让我们看看如何实现这一点，以及其工作原理和优缺点。

### 组合使用异步和多进程

在组合使用时，每个进程可以作为一个异步事件循环的实例。每个进程可以独立运行自己的事件循环，处理异步任务。通过这种方式，可以充分利用多核 CPU 的能力，同时保持异步模型的高效 I/O 处理。

### 实现方式

1. **启动多个进程**：
   可以使用 Python 的 `multiprocessing` 库来启动多个进程。每个进程将运行一个独立的事件循环。

2. **每个进程运行事件循环**：
   对于每个进程，使用异步编程框架（如 asyncio，FastAPI，uvicorn 等）启动一个事件循环。

示例如下：

```python
import asyncio
import multiprocessing
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/")
async def read_root():
    await asyncio.sleep(1)
    return {"message": "Hello, world!"}

def start_server(port):
    uvicorn.run(app, host="0.0.0.0", port=port)

if __name__ == "__main__":
    processes = []
    for i in range(multiprocessing.cpu_count()):
        port = 8000 + i  # For example, start multiple servers on different ports
        p = multiprocessing.Process(target=start_server, args=(port,))
        p.start()
        processes.append(p)

    for p in processes:
        p.join()
```

在这个示例中，每个进程运行一个 FastAPI 应用，并监听不同的端口。每个 FastAPI 应用在异步事件循环中处理请求。

### 优缺点

**优点**：
1. **资源利用**：充分利用多核处理器，以提高吞吐量。
2. **高并发**：由于每个进程都是异步的，可以处理大量并发 I/O 操作。
3. **隔离性**：进程隔离可以提高应用的稳定性，即使一个进程崩溃了，其他进程仍然可以继续运行。

**缺点**：
1. **复杂性**：管理多个进程和事件循环的组合增加了系统的复杂性。
2. **资源消耗**：每个进程仍然需要分配独立的资源，会比纯异步单进程模式消耗更多的内存。
3. **进程间通信**：需要处理进程间通信和负载均衡的问题，可以借助反向代理服务器（如 Nginx）或更高级的进程管理工具（如 Kubernetes）来实现。

### 总结

是的，异步编程可以和多进程组合来进一步提高负载能力。通过这种方法，可以充分利用多核处理器，同时享受异步编程模型带来的高效 I/O 处理能力。在面对超高并发的场景，这种组合的方式非常有效。

当然，在实际应用中，也可以借助一些成熟的解决方案和工具，如使用 Gunicorn 结合 Uvicorn 来启动一个 ASGI 应用，或使用 Kubernetes 管理和扩展多个容器实例。这些工具可以简化进程管理，并提供更好的负载均衡和故障恢复能力。

