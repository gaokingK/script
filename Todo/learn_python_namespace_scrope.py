"""
python 命名空间和作用域
link: https://www.runoob.com/python3/python3-namespace-scope.html
link2: https://www.cnblogs.com/windlaughing/archive/2013/05/26/3100362.html
命名空间: 是名称(names)到对象(objects)的映射, 大部分的命名空间是通过python字典来实现的, 的键就是变量名，它的值就是那些变量的值
    各个命名空间是独立的
    作用: 避免代码中名字冲突
    内置命名空间: 对每个模块都是全局的, 作为最后的尝试，Python 将假设 x 是内置函数或变量; 它记录了python语言内置的name, 如abs/char等
    全局命名空间: 特指当前的模块; 他记录了模块中定义的名称, 记录模块的变量, 包括函数/类/其他导入的模块, 模块级的变量和常量
    局部命名空间: 特指当前函数或类的方法, 它记录了函数的变量，包括函数的参数和局部定义的变量
命名空间的生命周期:
    取决于对象的作用域(scrope), 如果对象执行完成，则该命名空间的生命周期就结束, 这里的对象指的是什么,还能执行?
    所以我们无法从外部命名空间访问内部命名空间的对象(外部是指从全局访问局部, 应该是无法显示访问吧?)
    不同的命名空间在不同的时刻创建，有不同的生存期
        1、内置命名空间在 Python 解释器启动时创建，会一直保留，不被删除。
        2、模块的全局命名空间在模块定义被读入时创建，通常模块命名空间也会一直保存到解释器退出。
        3、当函数被调用时创建一个局部命名空间，当函数返回结果 或 抛出异常时，被删除。每一个递归调用的函数都拥有自己的命名空间。

作用域: 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称
    Local: 最内层, 包含局部变量
    Enclosing: 包含了非局部(non-local)也非全局(non-global)的变量
        比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于B中的名称来说A中的作用域就为nonlocal。
    Global: 当前脚本的最外层，比如当前模块的全局变量。
    Built-in: 包含了内建的变量/关键字等，最后被搜索。
        内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它
Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如if/elif/else/、try/except、for/while等）
    是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，
调用函数时，所有在函数内声明的变量名称都将被加入到作用域中
当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。

命名空间的查找顺序:
    按照局部>全局>内置的顺序去查找
嵌套函数的查找顺序:
    1. 先在当前 (嵌套的或 lambda) 函数的命名空间中搜索(注意不会去更里面一层的函数中去搜索,)
    2、然后是在父函数的命名空间中搜索
    3、接着是模块命名空间中搜索
    4、最后在内置命名空间中搜索

访问命名空间
    locals 实际上没有返回局部名字空间，它返回的是一个拷贝。所以对它进行改变对局部名字空间中的变量值并无影响。
　　globals 返回实际的全局名字空间，而不是一个拷贝。所以对 globals 所返回的 dictionary 的任何的改动都会直接影响到全局变量。
"""


"""
exerpise: python 特别之处
python有一个特别之处就是赋值总是在最里层的作用域. 赋值不会复制数据-只是将命名绑定到对象;
删除也是如此："del y" 只是从局部作用域的命名空间中删除命名 y 。事实上，所有引入新命名的操作都作用于局部作用域
i=1
def func2():
    i=i+1
 
func2();
#错误：UnboundLocalError: local variable 'i' referenced before assignment
解释: 由于创建命名空间时，python会检查代码并填充局部命名空间。在python运行那行代码之前，就发现了对i的赋值，
并把它添加到局部命名空间中。当函数执行时，python解释器认为i在局部命名空间中但没有值，所以会产生错误。
"""

b = 1
def func2():
    # i = b + 1  # 首先这条语句证明了能引用外部的全局变量
    b = b + 1  # 理想中这个b应该是全局变量b, 但不是 了解原因前先看另外一个问题: 赋值时的顺序是怎样的:
    # 当程序执行到上一行, 在命名空间中创建key b, 然后计算右边, 发现变量,然后按照变量查找顺序,在局部变量总找到b, 但是这个b只有key, 这种现象就是unboundnameerror
    # 所以原因就是和 a = a 是一样的


if __name__ == '__main__':
    func2()
