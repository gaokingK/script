# link：
- https://blog.csdn.net/qq15035899256/article/details/126073927
### UDP和TCP的区别 简单来说
- link：https://www.cnblogs.com/williamjie/p/9390164.html
- UDP是无连接的，所以只知道对端的IP和端口号就可以发送了，TCP是有连接管理的的，在建立连接时需要三次握手，断开连接时需要四次挥手
- UDP是不可靠的，没有确认机制，也没有重传机制，所以也不需要发送缓冲区；而TCP是可靠的，有重传机制，所以有发送缓冲区，tcp的可靠机制有引入序列号，保证数据按时到达；确认应答机制，保证对端收到了数据；超时重发机制，如果隔一段时间没有应答，就重新发送
- TCP还有流量控制、拥塞控制和滑动窗口
- 对系统的开销不一样（UDP小，TCP大）
- TCP是数据流、UDP是数据报（可以把数据流理解为传送带，数据是传送带上的一个一个包裹）
## TCP的可靠性机制：连接管理、确认应答、超时重发、流量控制，拥塞控制、滑动窗口
### 连接管理机制
- 三次握手
    - ![](https://img-blog.csdnimg.cn/99eba7198c6044b0ac3fa326da5b7656.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-D5Lit5peg5aWz5Lq6IOaVsueggeiHqueEtuelnu-8ge-8gQ==,size_10,color_FFFFFF,t_70,g_se,x_16)
    - 客户端准备建立连接，发送连接请求包（SYN包） SYN=1,seq=x(随机生成)
    - 服务器收到这个TCP报文，判断出是建立连接的，发送ACK包ACK=1，ack=x+1；发送SYN包SYN=1，seq=y（这两个包是一块发送的）
    - 客户端收到合并后的SYN包和ACK包，然后发送确认包ACK（ACK=1，ack=y+1,seq=x+1),然后就开始发送数据了
- 为什么会有三次握手？
    - 第一次握手确认了客户端的发送能力；第二次握手确认了服务端的发送能力和接受能力；第三次握手确认了客户端的发送能力，所以最少是三次
- 四次挥手
    - ![](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg@f_auto?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)
    - FIN是通知对方，本端要关闭连接的报文结束标识，四次挥手本质上就是双方各自给对方发送FIN，并且在收到对方发送的FIN后回复ACK
    - 四次挥手可以由客户端发起，也可以由服务端发起
- 为什么握手要三次，挥手要四次
    - 本质上都是4次的，不过握手过程中服务端发送ACK和SYN都是由系统内核执行的，由于是同一时机发送的，当然可以归为一次；而四次挥手中收到FIN的一方发送ACk是系统内核控制的，但之后这一端再发送FIN则需要应用的代码逻辑走到关闭时才发送FIN，如果由于这个时机是不确定的，所以通常认为是4次。
### 确认应答
- 接收端有责任对每个收到的数据包做出应答，这个就是确认应答机制
- ![](https://img-blog.csdnimg.cn/203e77357cdb4533b2cd37a8a12292d7.png)
- 发送端会对发送数据的每个字节进行编号
    - ![](https://img-blog.csdnimg.cn/6e71cc9e27334c15b74db418bff95f68.png)
- 接受方收到数据包后，会发送包含对应序列号的ACK，来告诉发送方我已经收到了那些数据，下一个应该从哪里开始发
### 超时重发
- 假如出现网络拥塞等原因，发送端没有都到接收端的ACK，就会在一定间隔内重新发送数据
- 如果是ACK没有被收到而数据包到达了，那么接收端就会收到好多重复的数据，这些数据可以通过数据包上的序列号给去重掉
- TCP为了保证在任何网络环境下都能高性能的进行通信，会动态的计算这个发送的间隔。
    - Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定超时重发的的尺度都是500ms的整数倍。
    - 一次超时重发后，这个时间变为2500ms，接下来是4500ms，超时时间以指数形式递增
    - 当累计到一定的重传次数，发送端就会认为网络或着对端出现问题而强制关闭连接，不会一直重传
- 这里的超时重发和滑动窗口中的丢包了的解决方法冲突吗？
    - 不冲突，因为这里的是没有收到ACK的解决方法，而滑动窗口中的解决方法是收到了ACK
### 流量控制
- TCP连接是有发送缓冲区和接受缓冲区的，如果发送端发送的数据太快，导致接受端的缓冲区被打满，如果还继续发送就有可能导致丢包，流量控制的作用就是根据接收端的缓冲区大小来调整发送频率
- 接收端收到发送端的TCP报文后，会将当前缓冲区的大小放在ACK中，这个字段的值越大，说明接收端的缓冲区空余越大，如果缓冲区的空间变小了，接收端就会调整应答报文中字段的值，当值为0时，发送端就不会发送数据了，但会定期发送报文来获取接收端的缓冲区大小。
### 拥塞控制
- TCP会根据当前的网络承载能力，来调整发送的速度，这就是拥塞控制，拥塞控制算法有 1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复
### 滑动窗口
- 再确认应答机制下，发送端对于每条发送出去的数据包都需要收到对应的确认报文，但是如果发送一条，等收到ACK后再发送下一条的话效率就太慢了，尤其是数据往返时间太长的情况下。滑动窗口机制就是将多条数据的等待时间重叠在一起
- 机制简介：
    - ![](https://blog.csdn.net/qq15035899256/article/details/126073927)
    - 窗口的大小就是可以不用等待确认报文而发送的数据的最大值，假设为4000
    - 当发送完第4段数据后，才开始等待接收端的ACK，收到1个ACK，滑动窗口就继续往下移动，继续发送第五段数据。收到多个，就移动多个。
    - 而操作系统内核为了维护这个滑动窗口，就必须开辟一块缓冲区来存放没有收到对应ACK的数据包，只有收到了，才会将数据从缓冲区中删除
- 发生丢包怎么办
- 情况A:接受端已经收到了，但ACK没有被发送端给接收到，这种不用担心，因为可以通过下一条数据的ACK进行确认
    - ![](https://img-blog.csdnimg.cn/d03ea1af7c254e62a79ee86dd8dee07d.png)
- 另一种情况是数据包没有到达接收端，接收端在后续收到的数据包的ACK中的序列号都会是这条丢失的数据，而由于上面情况A的原因，在刚收到对丢失数据的ACK时，发送方仍按照正常的顺序来发送数据，直到都到规定条数的重复确认应答（3次）才会把缓冲区中丢失的那条数据重新发送。然后再收到的ACK中就会是已发送中的最大序列号了（因为已发送的都被存储再接收端的缓冲区中了）
- 这种机制也被称为快重传机制。
## 其他问题
### 粘包问题
- 首先要明确一个问题，这个包指的是应用层的数据包，TCP是传输层协议；这些包不是不同应用的包（没有应用都有单独的端口号），而是一个应用的多个包，比如微信的两条信息。
- 发送端的应用层传下来的多个数据包在传输层中被TCP协议按照数据原本的顺序标记了一个个的序号，在接收端的传输层中，这些数据也是有序的，但是到了应用层中，由于TCP中没有UDP中标识数据长度的字段，应用层该怎么从这些连续的数据中区分每个数据包的位置呢？
- 如何避免粘包问题呢？就是要明确两个包之间的边界
    - 对于定长的数据包，可以每次从缓冲区读取该包长度大小的数据就好。
    - 对于变长的数据包，可以在包头的位置，约定一个包总长度的字符串；也可以由程序袁规定一个不会再数据包中出现的字符作为一个分隔符
### TCP SYN flood攻击
- https://cloud.tencent.com/developer/article/1683679
- tcp的三次握手过程中，当服务器发送完ACK和SYN的包后，会等待请求短的ACK包
- 攻击者发送大量的SYN包，服务器回应(SYN+ACK)包，但是攻击者不回应ACK包，这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。
