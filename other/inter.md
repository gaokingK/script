- 简述一个前端请求的处理流程，在uwsgi/nginx/django之间的处理流程
- redis用过哪些数据结构？怎么保存的
- redis为什么快？除了他是内存型数据库外，还有什么原因
- 描述一个东西是什么，可以从他是干什么的，他是怎么产生的，是什么时候出现的，生命周期是怎样等去描述、有什么约束、是怎么实现的
### 
- 项目中redis是做什么的
- restful 有什么特点
- 项目是干什么的，有哪些功能
- 自己会部署项目吗
- 写一个项目需要那些
    - 鉴权、接口校验、数据、handler、
- celery用来干啥 定时任务怎么做的
- 跨域怎么解决
- 正向代理反向代理
    - https://cloud.tencent.com/developer/article/1418457
- 都用到 docker 的哪些操作？
- 怎么去管理docker的，是shell侵入式还是docker的api，那技术选型上为什么不选择docker的api
- 还是项目
    - 介绍项目、项目的架构，自己的角色
    - k8s熟悉吗
    - 如何实现CI
- flask 清水池
- having to 子句 ，选择总分第二人的名字、解释下事务、视图、存储流程、游标
- 前端图表组件了解过哪些
- 参与过平台的设计吗？流程图画吗
- 建模语言了解过吗
- 介绍下k8s/docker/jekenis
- python 封装、继承、多态
- 存储引擎的区别
- djano 权限控制
    - https://blog.csdn.net/HHG20171226/article/details/93229831
    - has_perm()s
- 事务的特性
- redis的数据类型、存放排行榜
- python的内存管理
- flask的跨域、路由、django的日志配置
- django 排序 Track.objects.all().order_by('-id','title') - 解决
- new和init的区别 - 解决
- 把列表使用set去重后如何保持顺序和原来一样
- 负载均衡算法
    - https://zhuanlan.zhihu.com/p/68733507
    - 轮询、源地址hash、加权轮询、加权随机、最小连接数法
    - 加权就是根据服务器的负载能力大小分配不同权重，
    - 加权随机就是权重高的选中的概率大
- sqlarchme 分页怎么实现
    - 用offset()设置索引偏移量,limit()限制取出量 `db.session.query(User.name).filter(User.email.like('%'+email+'%')).limit(page_size).offset((page_index-1)*page_size)`
    - 用paginate(偏移量，取出量)函数,用于BaseQuery `user_obj=User.query.filter(User.email.like('%'+email+'%')).paginate(int(page_index), int(page_size),False)`
- GIL锁、GIL锁和互斥锁的区别
    - https://www.cnblogs.com/richardzgt/articles/7761172.html#_label0_3
    - 区别就是颗粒度的大小不同，而依赖CPU计算的线程则是执行代码量到一定的阀值，才会释放GIL
- GIL https://blog.csdn.net/weixin_36440198/article/details/113961683
    - 上面讲到Python在实现Python解析器(CPython)时引入了GIL锁，使得「在一个解释器内，任何时候仅有 一个线程在执行」，Python多线程的效率可能还比不上单线程，那么这个GIL锁是什么？

    - 概念：全局解释器锁，用于同步线程的一种机制，使得任何时候仅有一个线程在执行。GIL 并不是Python的特性，只是在实现Python解析器(CPython)时引入的一个概念。换句话说，Python完全可以不依赖于GIL。Python解释器进程内的多线程是以协同多任务方式执行的，当一个线程遇到I/O操作时会释放GIL,而依赖CPU计算的线程则是执行代码量到一定的阀值，才会释放GIL。

    - 而在Python 3.2开始使用新的GIL，使用固定的超时时间来指示当前线程放弃全局锁，就是：「当前线程持有这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放掉该锁。」多线程在处理CPU密集型操作因为各种循环处理计数等，会很快达到阀值，而**多个线程来回切换是会消耗资源的，所以多线程的效率往往可能还比不上单线程！
    - 如果只有一个进程，那么多核cpu上一个时刻也只有一个线程在运行，而在多核CPU上效率会更低，因为多核环境下，持有锁的CPU释放锁后，其他CPU上的线程都会进行竞争，但GIL可能马上又会被之前的CPU拿到拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，从而造成 线程颠簸(thrashing)，导致效率更低。
- 因为GIL锁的原因，对于CPU密集型操作，Python多线程就是鸡肋了？
    - 答：是的！尽管多线程开销小，但却无法利用多核优势！可以使用多进程来规避这个问题，Python提供了multiprocessing这个跨平台的模块来帮助我们实现多进程代码的编写。每个进程都有自己独立的内存空间和解释器，所以每个进程都有独立的GIL，因此不会出现进程间GIL锁抢夺的问题，但是也增加程序实现线程间数据通讯和同步时的成本，这个需要自行进行权衡。
- 如果3核CPU，为了达到最优执行效率，应该开几个进程呢
  - 理论上是可以开启无限个进程的，这取决于操作系统的多任务处理能力和机器的内存大小，操作系统会管理所有进程，并且在多个核心之间分配进程的执行
  - 但是每个进程都需要一定的系统资源，比如内存和处理器时间，如果开启的进程太多，可能会因为资源争抢导致系统性能下降或者不稳定
  - 理想情况下是开启和cpu核数相同的进程，每个进程都不会被调度，但是系统上一定会存在其他的背景进程用来支持操作系统和其他用户程序。

- 线程会在什么时候释放GIL
    - 执行IO操作时，当线程遇到文件读写、网络连接等会阻塞的IO时，会释放GIL，允许其他进程运行
    - 时间片结束后，python多线程中，每个线程会运行固定的时间，然后释放GIL让其他线程运行，这就是协同多任务处理
    - 执行阻塞系统调用，当线程执行系统调用或者其他阻塞操作时，线程也会释放GIL
    - 调用某些外部库，当线程调用某些外部库的函数时，可能会释放GIL
    - 注意释放GIL并不代表会切换到别的线程，仅代表别的线程有可能会拿到GIL，线程调度依赖于系统的调度机制
- 图和树的区别
    - 图没有根节点
- 走象棋
- 进程、线程、协程的区别
    - 协程有点类似于子程序，不过区别在于协程执行的过程中可以中断，执行别的协程
    - 协程和线程的区别
        - 协程的切换是由程序自身控制，没有线程切换的开销，所以有很高的执行效率
        - 不需要线程的锁机制、
    - 多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
- 进程能占满8个核、线程只能占用一个核
- 进程是系统资源分配的基本单位（可以看成是资源的容器），线程是调度的基本单位。

- flask 获取getpost参数
- mysql支持范围查询吗
- a="xxx" a[0]="2"不可以
- 索引的最左匹配

- top 显示某个用户的 -u
- 类的继承方式
- 析构 del
- 偏函数
    - 把函数的某些参数给固定住
- lambda 缺点
    - 不能在其他地方引用
- 创建索引的过程中可以插入数据吗
    - 可以这样回答，我没在创建索引的过程中插入过数据，但感觉创建索引的过程中是不会锁表的吧
- 数据库的4种隔离级别 幻读是什么
- int可以做dict的键吗？ 可以
- 软连接和硬链接的区别
- 用户权限777
- 训练集、测试集、验证集
- 缓存穿透、缓存雪崩和缓存击穿是与缓存系统相关的三种不同问题，它们都可能导致缓存的失效或性能下降。
- 缓存穿透和缓存击穿的区别在于前者找的数据哪里都不存在，后者找的数据只是在缓存里不存在
1. **缓存穿透（Cache Penetration）**：
   - **问题描述**：缓存穿透是指恶意或非常频繁地查询一个在缓存中不存在的数据，导致每次查询都落在数据库上，从而增加了数据库的负担。
   - **原因**：通常由于查询一个不存在的数据，而缓存不会命中，因此每次请求都会穿透到底层数据存储。
   - **解决方法**：可以在查询之前添加一些预处理，例如布隆过滤器（Bloom Filter）来过滤掉无效的查询请求，或者缓存空值以减轻数据库负载。

2. **缓存雪崩（Cache Avalanche）**：
   - **问题描述**：缓存雪崩是指缓存中的多个缓存项在大约相同的时间内失效或被清除，导致大量请求同时击中底层数据存储，引发系统性能问题。
   - **原因**：通常是由于多个缓存项设置了相同的过期时间，或者缓存服务器出现故障，导致缓存项一起失效。
   - **解决方法**：避免设置相同的过期时间，采用随机的过期时间分散缓存项的失效时间，以减少缓存项同时失效的可能性。此外，使用缓存高可用性解决方案来防止缓存服务器单点故障。

3. **缓存击穿（Cache Miss）**：
   - **问题描述**：缓存击穿是指一个缓存中不存在但在底层数据存储中存在的数据项被大量请求，导致大量的请求直接击中底层数据存储，增加了其负担。
   - **原因**：通常是由于某个热门数据项的缓存过期，而大量请求同时到达，导致缓存无法命中。
   - **解决方法**：可以采用互斥锁或分布式锁来控制多个请求同时查询缓存中不存在的数据项，以避免同时触发多次数据库查询。

为了有效地处理这些问题，通常需要综合考虑缓存策略、过期时间的随机化、缓存监控和高可用性等多种方法。不同的应用场景和需求可能需要不同的解决方案。
